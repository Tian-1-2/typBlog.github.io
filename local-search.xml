<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>列表内容过多卡顿？有索引栏如何实现滚动加载？</title>
    <link href="/Tian-1-2/typblog/2024/07/31/2024731-%E5%88%97%E8%A1%A8%E5%86%85%E5%AE%B9%E8%BF%87%E5%A4%9A%E5%8D%A1%E9%A1%BF%EF%BC%9F%E6%9C%89%E7%B4%A2%E5%BC%95%E6%A0%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%EF%BC%9F/"/>
    <url>/Tian-1-2/typblog/2024/07/31/2024731-%E5%88%97%E8%A1%A8%E5%86%85%E5%AE%B9%E8%BF%87%E5%A4%9A%E5%8D%A1%E9%A1%BF%EF%BC%9F%E6%9C%89%E7%B4%A2%E5%BC%95%E6%A0%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="列表内容过多卡顿？有索引栏如何实现滚动加载？"><a href="#列表内容过多卡顿？有索引栏如何实现滚动加载？" class="headerlink" title="列表内容过多卡顿？有索引栏如何实现滚动加载？"></a>列表内容过多卡顿？有索引栏如何实现滚动加载？</h2><h4 id="👓写在前面"><a href="#👓写在前面" class="headerlink" title="👓写在前面"></a>👓写在前面</h4><p>很多小伙伴可能在开发业务中会遇到这种问题，数据列表过多，造成dom一次性渲染卡顿，本文主要介绍滚动加载，实现在有索引栏的列表中使用滚动加载的方法。</p><p>本文技术栈使用的是vue2+vant2，其他框架组件库也都有相似之处，可以做个参考</p><h4 id="🥇Vant自带组件滚动加载"><a href="#🥇Vant自带组件滚动加载" class="headerlink" title="🥇Vant自带组件滚动加载"></a>🥇Vant自带组件滚动加载</h4><p>vant组件库已经提供了一种滚动加载的方法，<a href="https://vant-ui.github.io/vant/v2/#/zh-CN/list">参考链接</a></p><h5 id="List组件"><a href="#List组件" class="headerlink" title="List组件"></a>List组件</h5><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240731101141490.png" alt="image-20240731101141490"></p><blockquote><p>List 组件通过 <code>loading</code> 和 <code>finished</code> 两个变量控制加载状态，当组件滚动到底部时，会触发 <code>load</code> 事件并将 <code>loading</code> 设置成 <code>true</code>。此时可以发起异步操作并更新数据，数据更新完毕后，将 <code>loading</code> 设置成 <code>false</code> 即可。若数据已全部加载完毕，则直接将 <code>finished</code> 设置成 <code>true</code> 即可。</p></blockquote><p>📋这里需要注意一个点是，当完全加载完毕时，其<strong>load事件</strong>不会再触发，所以再切换数据或者其他不会导致组件重新渲染的操作时，这个load事件也不会触发，这个时候需要进行下面操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//把完成状态改为未完成</span><br><span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">false</span><br><span class="hljs-comment">// 切换时触发是否滑到底部检查</span><br><span class="hljs-keyword">this</span>.$refs.lists.check()<br></code></pre></td></tr></table></figure><p><strong>check方法介绍</strong></p><p>通过 ref 可以获取到 List 实例并调用实例方法，详见<a href="https://vant-ui.github.io/vant/v2/#/zh-CN/advanced-usage#zu-jian-shi-li-fang-fa">组件实例方法</a>。</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th><th align="left">参数</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="left">check</td><td align="left">检查当前的滚动位置，若已滚动至底部，则会触发 load 事件</td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="🍳索引栏列表实现滚动加载"><a href="#🍳索引栏列表实现滚动加载" class="headerlink" title="🍳索引栏列表实现滚动加载"></a>🍳索引栏列表实现滚动加载</h4><p>vant组件库中还有一个indexBar索引栏组件</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240731103431814.png" alt="image-20240731103431814"></p><p>可以根据右侧索引栏点击跳转到对应列表，而且这种就不能简单的靠List组件实现滚动加载了</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>可以主要分为下面几步</p><ol><li>在indexBar外包裹List组件，先实现普通的滚动加载</li><li>添加索引栏绑定事件</li><li>判断点击索引是否存在，进行调整还是添加数据</li></ol><p>第一步不用过多赘述，实现比较简单，直接看第二步</p><p><strong>添加索引栏绑定事件</strong></p><p>添加绑定事件是因为vant索引栏有一个缺陷，如何对应的索引列表没有对应的值，索引栏点击没有效果，所以这个会影响咱们后续操作，这里是采用的原生绑定事件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 根据样式获取其元素</span><br>const boxes = document.query<span class="hljs-constructor">SelectorAll(<span class="hljs-string">&quot;.van-index-bar__index&quot;</span>)</span><br>boxes.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">box</span>)</span> =&gt; &#123;<br>box.add<span class="hljs-constructor">EventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-params">function</span> <span class="hljs-params">handleClick</span>(<span class="hljs-params">event</span>)</span> &#123;<br><span class="hljs-comment">//获取当前点击索引</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_this</span>.</span></span>enum = box.innerHTML<br><br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>判断加载数据</strong></p><p>这个时候需要判断点击的索引是否存在已经加载的数据中，如果存在会自动跳转，不存在则调用加载数据的方法，同时IndexBar组件库有scrollTo方法，可以跳到对应索引，我这里判断*是跳到第一个</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//全部字母列表点击事件</span><br>handleAllLetterClick() &#123;<br>let _this = <span class="hljs-keyword">this</span>;<br><span class="hljs-comment">//判断选中的字母是否在已经加载的数组内</span><br>let index = _this.list.findIndex((element) =&gt; element.capitalInitia == <span class="hljs-keyword">this</span>.<span class="hljs-keyword">enum</span>);<br><span class="hljs-comment">//已存在 会自动跳转</span><br><span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-keyword">enum</span> == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br><span class="hljs-comment">// 点击*回到第一个字母</span><br><span class="hljs-keyword">this</span>.$refs.IndexBar.scrollTo(<span class="hljs-keyword">this</span>.content[<span class="hljs-number">0</span>].capitalInitia);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>_this.onLoad(<span class="hljs-string">&#x27;jump&#x27;</span>);<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>onLoad方法，这里是把数据分成两部分，list是展示数据，content是全部数据，一次加载五个数组，如果点击索引没有获取到会递归调用，直至获取到，或数据加载完毕</p><blockquote><p>📃注意点：我这里是一次获取所有数据然后在前端处理，另一种方法可以采用分页获取方法，在此方法中异步调用，看与后端人员如何定义了</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">onLoad(type) &#123;<br>let add = <span class="hljs-number">0</span><br><span class="hljs-comment">//此步可以用异步调用替换</span><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-keyword">this</span>.list.length; i &lt; <span class="hljs-keyword">this</span>.content.length; i++) &#123;<br><span class="hljs-keyword">this</span>.list.push(<span class="hljs-keyword">this</span>.content[i])<br>add++<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.content.length == <span class="hljs-keyword">this</span>.list.length) &#123;<br><span class="hljs-comment">// 数据全部加载完成</span><br><span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> (add &gt;= <span class="hljs-number">5</span>) &#123;<br><span class="hljs-comment">// 加载状态结束</span><br><span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>let index = <span class="hljs-keyword">this</span>.list.findIndex((element) =&gt; element.capitalInitia ==<span class="hljs-keyword">this</span>.<span class="hljs-keyword">enum</span>);<br><span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">//点击才跳转</span><br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&#x27;jump&#x27;</span>) &#123;<br><span class="hljs-keyword">this</span>.$refs.IndexBar.scrollTo(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">enum</span>);<br>&#125;<br><span class="hljs-comment">//已存在</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.content.length &gt; <span class="hljs-keyword">this</span>.list.length) &#123;<br><span class="hljs-keyword">this</span>.onLoad();<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="🎨总结"><a href="#🎨总结" class="headerlink" title="🎨总结"></a>🎨总结</h4><p>实现原理其实就是一点一点加入，具体怎么加入，什么时候加入，是实现这个功能的主要点，其他组件库都可以按照类似方法进行实现，欢迎交流！</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>别再用this.$forceUpdate()了！—性能优化篇</title>
    <link href="/Tian-1-2/typblog/2024/07/01/202471-%E5%88%AB%E5%86%8D%E7%94%A8this.$forceUpdate()%E4%BA%86%EF%BC%81%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    <url>/Tian-1-2/typblog/2024/07/01/202471-%E5%88%AB%E5%86%8D%E7%94%A8this.$forceUpdate()%E4%BA%86%EF%BC%81%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="别再用this-forceUpdate-了！—性能优化篇"><a href="#别再用this-forceUpdate-了！—性能优化篇" class="headerlink" title="别再用this.$forceUpdate()了！—性能优化篇"></a>别再用this.$forceUpdate()了！—性能优化篇</h2><p>起因是接手公司之前外包的项目做项目优化，代码看着一言难尽，然后看代码时，发现了这个api:<code>this.$forceUpdate()</code>，这是什么？</p><h4 id="🎈介绍"><a href="#🎈介绍" class="headerlink" title="🎈介绍"></a>🎈介绍</h4><p>这里官网介绍很简单，</p><blockquote><p>vm.$forceUpdate()<br>示例：<br>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p></blockquote><p>还有一段介绍，但是是用于强制更新这一方法的</p><blockquote><p>如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。</p><p>你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p><p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate来做这件事。</p></blockquote><p>就是说这个方法是用来强制更新的！但是官网说你很可能是你的问题，你哪个地方做错了！</p><h4 id="🧨弊端"><a href="#🧨弊端" class="headerlink" title="🧨弊端"></a>🧨弊端</h4><p>$forceUpdate()会迫使 Vue 实例重新渲染，所以就会有一个问题，那就是重新渲染dom，造成性能压力，而且绕过了vue的正常响应式系统，就抛弃了响应式了，那就有点因噎废食了。</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>$forceUpdate()会触发<code>beforeUpdate</code>和<code>updated</code>生命周期</p><p>$forceUpdate()只会影响实例本身和插入插槽内容的子组件</p><h4 id="🎆解决实例"><a href="#🎆解决实例" class="headerlink" title="🎆解决实例"></a>🎆解决实例</h4><p>项目原先代码中，先进行遍历catchs数组中，修改每个对象中的active属性，随后进行更改为false，然后再传参进来的值对应的active值修改为true，原来的兄弟可能看，数据变了怎么不更新啊，没有排查出问题，直接全部重新渲染，真是简单痛快呀。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">thisCatch</span><span class="hljs-params">(index)</span></span> &#123;<br>      this<span class="hljs-selector-class">.catchs</span><span class="hljs-selector-class">.forEach</span>((element,index) =&gt; &#123;<br>        element<span class="hljs-selector-class">.active</span> = false<br>      &#125;)<br>      this<span class="hljs-selector-class">.catchs</span><span class="hljs-selector-attr">[index]</span><span class="hljs-selector-class">.active</span> = true<br>      this.<span class="hljs-variable">$forceUpdate</span>()<br> &#125;,<br></code></pre></td></tr></table></figure><p>那就轮到我优化了，首先发现一个点是catchs数组中对象对应的值没有active这个属性，而vue2中响应式就有一个缺陷就是新增属性没有响应式。</p><p>所以到这就是两个方法，给默认值或者添加值让它有响应式</p><p>默认值好理解，实现响应式其实也挺简单就是使用$set</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">this<span class="hljs-constructor">Catch(<span class="hljs-params">index</span>)</span> &#123;<br>      this.catchs.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">element</span>,<span class="hljs-params">index</span>)</span> =&gt; &#123;<br>        this.<span class="hljs-constructor">$set(<span class="hljs-params">this</span>.<span class="hljs-params">days</span>[<span class="hljs-params">index</span>], &#x27;<span class="hljs-params">active</span>&#x27;, <span class="hljs-params">false</span>)</span>;<br>      &#125;)<br>      this.<span class="hljs-constructor">$set(<span class="hljs-params">this</span>.<span class="hljs-params">days</span>[<span class="hljs-params">index</span>], &#x27;<span class="hljs-params">active</span>&#x27;, <span class="hljs-params">true</span>)</span>;<br> &#125;,<br></code></pre></td></tr></table></figure><p>很简单就解决了问题，所以其实就正如官网说的😂</p><blockquote><p>如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/Tian-1-2/typblog/2024/06/12/20240612%E8%A2%ABnode-sass%E6%8A%98%E7%A3%A8%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <url>/Tian-1-2/typblog/2024/06/12/20240612%E8%A2%ABnode-sass%E6%8A%98%E7%A3%A8%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: 踩坑！被node-sass折磨的一天<br><br>date: 2024/6/12 20:46:25<br><br>categories: sass<br><br><span class="hljs-keyword">tags:</span> sass<br></code></pre></td></tr></table></figure><meta name="referrer" content="no-referrer"/><h2 id="被node-sass折磨的一天"><a href="#被node-sass折磨的一天" class="headerlink" title="被node-sass折磨的一天"></a>被node-sass折磨的一天</h2><h5 id="折磨过程"><a href="#折磨过程" class="headerlink" title="折磨过程"></a>折磨过程</h5><p>起因是要开发一个老项目，照常拉代码、下依赖、启动三步走</p><p>依赖开始下载不对了，以为是node版本问题，寻找node-sass对应的node版本</p><p>利用nvm，这几个版本都试了</p><p>​    <img src="data:image/png;base64,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" alt="0"></p><p>无果，根据报错解决问题，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Cannot downloadhttps:<span class="hljs-regexp">//</span>npm.taobao.org<span class="hljs-regexp">/mirrors/</span>node-sass<span class="hljs-regexp">/v4.14.1/</span>win32-x64-<span class="hljs-number">64</span>_binding.node<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>首先报错不能下载，以为是淘宝数据源过期了，于是更换成腾讯的</p><p>依然错误</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gyp <span class="hljs-keyword">ERR</span>! <span class="hljs-keyword">stack</span> <span class="hljs-keyword">Error</span>: Can&#x27;t find Python executable <span class="hljs-string">&quot;python&quot;</span>, you can <span class="hljs-keyword">set</span> the PYTHON env variable.<br></code></pre></td></tr></table></figure><p>找不到python环境，整蒙了我，难道要我再下个python？</p><p>百度原因是：这个错误是由node-gyp引起的，node-gyp是一个用于编译Node.js原生模块的工具，它依赖于Python环境。错误信息表明node-gyp无法找到Python可执行文件。</p><p>解决方法是可以安装python，或者安装node-gyp</p><p>安装python是不可能安装的，我就试了第二张，依然无果，</p><p>想着应该就是版本过老吧，那我就升级！</p><p>试着升级单个依赖，不行依然报错，</p><p>尝试利用npm-check-updates，结果吓我一跳！全给我干到最新版本了</p><p>​    <img src="data:image/png;base64,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" alt="0"></p><p>vue版本都从2干到3了，撤回！撤回！</p><p>这肯定有什么解决方法，对最新的项目为什么没有这个问题呢，我去看了看，</p><p>package.json里面怎么没有node-sass？没有sass-loader？只有sass！</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240612170555282.png" alt="image-20240612170555282"></p><p>……</p><p>先上解决方法</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">卸载 <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span>：npm uninstall <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> <br><br>安装 sass：npm install sass --save-dev<br></code></pre></td></tr></table></figure><p>解决不了它，就替换它，成功运行</p><h5 id="了解原因"><a href="#了解原因" class="headerlink" title="了解原因"></a>了解原因</h5><p>sass 是由 ts调用 dart-sass实现的工具类，来编译 sass</p><p>Dart Sass 是 Sass 官网力推的工具，它包括了基于 Dart VM 的命令行工具，以及基于 Node 的纯 Javascript 实现，不管是安装还是兼容高版本 Node这块，遥遥领先！</p><p>而node-sass 是用 node (调用 c++ 编写的 libsass) 来编译 sass，比较依赖node版本，下载安装较为麻烦，果断舍弃</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>在深度选择器这一块，注意更换</p><ol><li>sass 只支持 ::v-deep</li><li>node-sass 支持 &#x2F;deep&#x2F;和::v-deep</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目部署到子目录，路由跳转却到主域名下？正常能访问一刷新就404？——路由模式的困扰</title>
    <link href="/Tian-1-2/typblog/2024/05/16/2024516-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E5%AD%90%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%8D%B4%E5%88%B0%E4%B8%BB%E5%9F%9F%E5%90%8D%E4%B8%8B%EF%BC%9F%E6%AD%A3%E5%B8%B8%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%80%E5%88%B7%E6%96%B0%E5%B0%B1404%EF%BC%9F%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%B0%E6%89%B0/"/>
    <url>/Tian-1-2/typblog/2024/05/16/2024516-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E5%AD%90%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%8D%B4%E5%88%B0%E4%B8%BB%E5%9F%9F%E5%90%8D%E4%B8%8B%EF%BC%9F%E6%AD%A3%E5%B8%B8%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%80%E5%88%B7%E6%96%B0%E5%B0%B1404%EF%BC%9F%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%B0%E6%89%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="项目部署到子目录，路由跳转却到主域名下？正常能访问一刷新就404？——路由模式的困扰"><a href="#项目部署到子目录，路由跳转却到主域名下？正常能访问一刷新就404？——路由模式的困扰" class="headerlink" title="项目部署到子目录，路由跳转却到主域名下？正常能访问一刷新就404？——路由模式的困扰"></a>项目部署到子目录，路由跳转却到主域名下？正常能访问一刷新就404？——路由模式的困扰</h2><p>今天在做项目部署到一个服务器子目录时，遇到了两个问题，这里做下记录</p><h3 id="一、路由模式介绍"><a href="#一、路由模式介绍" class="headerlink" title="一、路由模式介绍"></a>一、路由模式介绍</h3><p>这里以Vue Router v4版本为例</p><p>在Vue Router v4版本有三种模式，官网已经做了详细介绍</p><h4 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h4><p>hash 模式是用 <code>createWebHashHistory()</code> 创建的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),<br>  <span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">//...</span><br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>它在内部传递的实际 URL 之前使用了一个哈希字符（<code>#</code>）。由于这部分 URL 从未被发送到服务器，所以它不需要在服务器层面上进行任何特殊处理。不过，<strong>它在 SEO 中确实有不好的影响</strong>。如果你担心这个问题，可以使用 HTML5 模式。</p><h4 id="Memory-模式"><a href="#Memory-模式" class="headerlink" title="Memory 模式"></a>Memory 模式</h4><p>Memory 模式不会假定自己处于浏览器环境，因此不会与 URL 交互<strong>也不会自动触发初始导航</strong>。这使得它非常适合 Node 环境和 SSR。它是用 <code>createMemoryHistory()</code> 创建的，并且<strong>需要你在调用 <code>app.use(router)</code> 之后手动 push 到初始导航</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createRouter, createMemoryHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createMemoryHistory</span>(),<br>  <span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">//...</span><br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>虽然不推荐，你仍可以在浏览器应用程序中使用此模式，但请注意<strong>它不会有历史记录</strong>，这意味着你无法<em>后退</em>或<em>前进</em>。</p><h4 id="HTML5-模式（v3版本中称为History模式）"><a href="#HTML5-模式（v3版本中称为History模式）" class="headerlink" title="HTML5 模式（v3版本中称为History模式）"></a>HTML5 模式（v3版本中称为History模式）</h4><p>用 <code>createWebHistory()</code> 创建 HTML5 模式，推荐使用这个模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  <span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">//...</span><br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>当使用这种历史模式时，URL 会看起来很 “正常”，例如 <code>https://example.com/user/id</code>。漂亮!</p><p>不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <code>https://example.com/user/id</code>，就会得到一个 404 错误。这就尴尬了。</p><p>不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 <code>index.html</code> 相同的页面。漂亮依旧!</p><p>更详细参考<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#HTML5-%E6%A8%A1%E5%BC%8F">官网介绍</a></p><h3 id="二、遇到的问题"><a href="#二、遇到的问题" class="headerlink" title="二、遇到的问题"></a>二、遇到的问题</h3><h4 id="1-项目部署到子目录，路由跳转却到主域名下解决方法"><a href="#1-项目部署到子目录，路由跳转却到主域名下解决方法" class="headerlink" title="1.项目部署到子目录，路由跳转却到主域名下解决方法"></a>1.项目部署到子目录，路由跳转却到主域名下解决方法</h4><p>如果是history模式，需要加上当前部署的子目录，</p><p>createWebHistory（）方法可以传入base参数，官网如下介绍：</p><p>base：基准路径，它被预置到每个 URL 上。这允许在一个域名子文件夹中托管 SPA，例如将 <code>base</code> 设置为 <code>/sub-folder</code> 使得其托管在 <code>example.com/sub-folder</code>。</p><p>所以代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>获取当前路径<br>let path = location.pathname.substring(<span class="hljs-number">0</span>, location.pathname.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>)<br>const router = createRouter(&#123;<br>  history: createWebHistory(path),<br>  routes: [<br>    <span class="hljs-regexp">//</span>...<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><p>！打包配置这里路径也需要注意下</p><p>这里我用的是vite</p><p>defineConfig中的base配置路径，有三种写法如下</p><ul><li>绝对 URL 路径名，例如 <code>/foo/</code></li><li>完整的 URL，例如 <code>https://foo.com/</code>（原始的部分在开发环境中不会被使用）</li><li>空字符串或 <code>./</code>（用于嵌入形式的开发）</li></ul><p>举例：</p><p>如果你的应用被部署在 <a href="https://www.xxxx/admin/%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AE">https://www.xxxx/admin/，则设置</a> base可以设为为 </p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;/admin/</span>&#x27;<br>&#x27;&#x27;<br><span class="hljs-symbol">&#x27;./</span>&#x27;<br></code></pre></td></tr></table></figure><p>这三种其一即可</p><h4 id="2-正常能访问一刷新就404解决方法"><a href="#2-正常能访问一刷新就404解决方法" class="headerlink" title="2.正常能访问一刷新就404解决方法"></a>2.正常能访问一刷新就404解决方法</h4><p>这个是因为没后端没进行配置，加载单页应用后路由改变均由浏览器处理，而刷新时将会请求当前的链接，而Nginx无法找到对应的页面</p><p>这时候需要在在Nginx配置文件nginx.conf中加入如下配置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html;<br></code></pre></td></tr></table></figure><p>这里做下举例:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">location ^~<span class="hljs-regexp">/xxxx/</span> &#123;<br>      root  /xx<br>      try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html;<br>    &#125;<br></code></pre></td></tr></table></figure><p>还有另一种方法可以同时解决上述两个问题，比如说就不想操作Nginx配置了，那就是更换称为<strong>hash</strong>模式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">const <span class="hljs-attr">router</span> <span class="hljs-operator">=</span> createRouter(<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  history:</span> createWebHashHistory(path),<br><span class="hljs-symbol">  routes:</span> [<br>    <span class="hljs-comment">//...</span><br>  ],<br><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p>但是会有一些缺点，如上面介绍，自行选择</p>]]></content>
    
    
    <categories>
      
      <category>项目部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文教会女朋友学会日常Git使用！Git知识总结</title>
    <link href="/Tian-1-2/typblog/2024/04/02/202442-%E4%B8%80%E6%96%87%E6%95%99%E4%BC%9A%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%AD%A6%E4%BC%9A%E6%97%A5%E5%B8%B8Git%E4%BD%BF%E7%94%A8%EF%BC%81Git%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/Tian-1-2/typblog/2024/04/02/202442-%E4%B8%80%E6%96%87%E6%95%99%E4%BC%9A%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%AD%A6%E4%BC%9A%E6%97%A5%E5%B8%B8Git%E4%BD%BF%E7%94%A8%EF%BC%81Git%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一文教会女朋友学会日常Git使用！Git知识总结"><a href="#一文教会女朋友学会日常Git使用！Git知识总结" class="headerlink" title="一文教会女朋友学会日常Git使用！Git知识总结"></a>一文教会女朋友学会日常Git使用！Git知识总结</h2><p>女朋友最近在学习git这块知识，我给他推荐了视频和廖雪峰的git文档，但是奈何新手刚开始学习，还是依然吃力，而日常工作中git这一部分使用其实并不难，所以也为了减轻女朋友的压力，这篇文章来了。</p><p>本文章涉及原理较少，主要是日常工作中直接使用，适合新手快速入门,如何想详细全面了解，还是推荐<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰git讲解</a></p><h3 id="一、git基本知识了解"><a href="#一、git基本知识了解" class="headerlink" title="一、git基本知识了解"></a>一、git基本知识了解</h3><h4 id="1-git简介"><a href="#1-git简介" class="headerlink" title="1.git简介"></a>1.git简介</h4><p>Git是一个分布式版本控制系统，简单来说就是代码版本控制系统，在日常工作中，开发人员就需要利用git将各个人的写的代码放到一起。再简单来说，就是用来提交代码的。</p><h4 id="2-git区域了解"><a href="#2-git区域了解" class="headerlink" title="2.git区域了解"></a>2.git区域了解</h4><p>区域这块主要便于后续操作理解，主要分成下面四个区域</p><ul><li>工作区：处理工作的区域（即做项目打代码的区域，你写代码的地方）</li><li>暂存区：已完成的工作临时存放区域，等待被提交（使用git add .操作后代码进入区域）</li><li>本地仓库：存放数据的地方，但是还在本电脑上（使用git commit -m “xxx”操作后代码进入区域）</li><li>Git远程仓库：最终的存放区域，即远程服务器(git push成功后代码推送的地方，就是代码仓库，比如Gitee、GitHub上建的仓库)</li></ul><p>下面这张图比较直观，可以做参考</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240328141101581.png" alt="image-20240328141101581"></p><h4 id="3-git常用命令"><a href="#3-git常用命令" class="headerlink" title="3.git常用命令"></a>3.git常用命令</h4><p><strong>连接远程仓库</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git remote <span class="hljs-built_in">add</span> xxx(例如：git remote <span class="hljs-built_in">add</span> origin 复制的ssh地址或者https地址)<br></code></pre></td></tr></table></figure><p><strong>克隆远程仓库</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">xxx</span>(例如：git <span class="hljs-keyword">clone</span> <span class="hljs-title">复制的ssh</span>地址或者https地址)<br></code></pre></td></tr></table></figure><p><strong>创建分支并切换到该分支</strong> </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git checkout -<span class="hljs-keyword">b </span>分支名称<br><br>相当于 git <span class="hljs-keyword">branch </span>dev <br>  git checkout dev<br></code></pre></td></tr></table></figure><p><strong>切换分支</strong> </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout develop</span><br></code></pre></td></tr></table></figure><p><strong>添加到暂存区</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><p><strong>添加到本地仓库</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit <span class="hljs-string">&quot;....&quot;</span><br></code></pre></td></tr></table></figure><p><strong>拉取远程仓库内容</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">git pull <span class="hljs-comment">(例如：git pull origin dev 最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突 再推送)</span><br></code></pre></td></tr></table></figure><p><strong>推送到远程仓库</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> (例如:git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> dev 上传到dev分支仓库)<br></code></pre></td></tr></table></figure><p><strong>备份当前的工作区修改的内容</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> stash  备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br></code></pre></td></tr></table></figure><p><strong>读取最近一次备份的内容</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git stash <span class="hljs-built_in">pop</span>: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，<span class="hljs-built_in">pop</span>会从最近的一个stash中读取内容并恢复<br></code></pre></td></tr></table></figure><h3 id="二、常用工作场景"><a href="#二、常用工作场景" class="headerlink" title="二、常用工作场景"></a>二、常用工作场景</h3><h4 id="1-克隆远程仓库，把仓库代码拉到本地"><a href="#1-克隆远程仓库，把仓库代码拉到本地" class="headerlink" title="1.克隆远程仓库，把仓库代码拉到本地"></a>1.克隆远程仓库，把仓库代码拉到本地</h4><p>这里以码云为例复制shh或者https</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240401134113463.png" alt="image-20240401134113463"></p><p>执行下面克隆命令即可</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@gitee.com:typhome/pinball-games.git<br></code></pre></td></tr></table></figure><p>克隆到本地，就可以进行本地代码修改了</p><h4 id="2-推送代码到远程仓库"><a href="#2-推送代码到远程仓库" class="headerlink" title="2.推送代码到远程仓库"></a>2.推送代码到远程仓库</h4><p>推送代码到远端分为几种情况</p><h5 id="（1）本地代码和远程仓库版本相同，在你之前没有其他人推上代码"><a href="#（1）本地代码和远程仓库版本相同，在你之前没有其他人推上代码" class="headerlink" title="（1）本地代码和远程仓库版本相同，在你之前没有其他人推上代码"></a>（1）本地代码和远程仓库版本相同，在你之前没有其他人推上代码</h5><p>这时执行三步骤即可</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .<br><br>git commit <span class="hljs-string">&quot;....&quot;</span><br><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><h5 id="（2）在你之前有其他人推上代码，但是和你修改的不是同一个文件"><a href="#（2）在你之前有其他人推上代码，但是和你修改的不是同一个文件" class="headerlink" title="（2）在你之前有其他人推上代码，但是和你修改的不是同一个文件"></a>（2）在你之前有其他人推上代码，但是和你修改的不是同一个文件</h5><p>这个时候需要先把别人的代码拉下来了，先进行git pull</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git pull<br><br>git <span class="hljs-keyword">add</span> .<br><br>git commit <span class="hljs-string">&quot;....&quot;</span><br><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><h5 id="（3）在你之前有其他人推上代码，和你修改的有同一个文件"><a href="#（3）在你之前有其他人推上代码，和你修改的有同一个文件" class="headerlink" title="（3）在你之前有其他人推上代码，和你修改的有同一个文件"></a>（3）在你之前有其他人推上代码，和你修改的有同一个文件</h5><p>这个时候直接git pull会报错，具体详细可以看我另一篇博客：<a href="https://blog.csdn.net/qq_49907632/article/details/129492150?spm=1001.2014.3001.5502">解决git pull时出现冲突无法pull的问题</a></p><p>主要方法就是将代码提到git栈中进行储藏，然后拉下代码后再应用，</p><p>主要步骤</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> stash<br><br><span class="hljs-symbol">git</span> pull<br><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><br><span class="hljs-symbol">git</span> stash <span class="hljs-keyword">pop</span> <br>(解决冲突)<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><br><span class="hljs-symbol">git</span> commit <span class="hljs-string">&quot;....&quot;</span><br><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span><br><br></code></pre></td></tr></table></figure><h5 id="（3）在a分支修改了，但是我要修改的内容应该在b分支上"><a href="#（3）在a分支修改了，但是我要修改的内容应该在b分支上" class="headerlink" title="（3）在a分支修改了，但是我要修改的内容应该在b分支上"></a>（3）在a分支修改了，但是我要修改的内容应该在b分支上</h5><p>这个时候在a分支修改了，没有提交，直接切换到b分支上会报错切换不了，这个时候也需要用到stash了</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">//先进行备份</span><br><span class="hljs-symbol">git</span> stash<br><span class="hljs-comment">//切分支</span><br><span class="hljs-symbol">git</span> checkout <span class="hljs-keyword">b</span><br><span class="hljs-comment">//拉下最新代码</span><br><span class="hljs-symbol">git</span> pull<br><span class="hljs-comment">//再应用推送即可</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><br><span class="hljs-symbol">git</span> stash <span class="hljs-keyword">pop</span><br>(解决冲突)<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><br><span class="hljs-symbol">git</span> commit <span class="hljs-string">&quot;....&quot;</span><br><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span><br><br></code></pre></td></tr></table></figure><p>以上几种情况基本满足日常工作需求，主要就是代码拉取和推送</p><h3 id="三、Git图形工具推荐"><a href="#三、Git图形工具推荐" class="headerlink" title="三、Git图形工具推荐"></a>三、Git图形工具推荐</h3><p>平常敲命令可能过于麻烦，或者不那么直观，这里推荐两个我常用的，提高开发效率，但是建议在git命令熟悉后或者使用一段时间后，再使用图形界面操作git</p><h4 id="1-vscode上自带的"><a href="#1-vscode上自带的" class="headerlink" title="1.vscode上自带的"></a>1.vscode上自带的</h4><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240401142403154.png" alt="image-20240401142403154"></p><p>可以看修改代码对比、切换分支、提交、stash等等，也是非常直观方便</p><h4 id="2-Soucetree"><a href="#2-Soucetree" class="headerlink" title="2.Soucetree"></a>2.Soucetree</h4><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240401143104695.png" alt="image-20240401143104695"></p><p>Soucetree是我最常用的git图形界面了，相比于vscode自带的更直观了，对于分支的操作更方便。</p><p>我认为唯一不足的就是修改代码对比，soucetree只显示修改行对比，而vscode的左右代码整个文件对比</p><p>感觉更直观一点。</p><p>这两种方式具体操作这里不具体介绍了，大家自行百度即可。有什么看法也欢迎讨论~</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>echarts实现两个y轴0刻度保持一致（多条数据时）</title>
    <link href="/Tian-1-2/typblog/2024/03/27/2024327-echarts%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AAy%E8%BD%B40%E5%88%BB%E5%BA%A6%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%88%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%89/"/>
    <url>/Tian-1-2/typblog/2024/03/27/2024327-echarts%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AAy%E8%BD%B40%E5%88%BB%E5%BA%A6%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%88%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="echarts实现两个y轴0刻度保持一致（多条数据时）"><a href="#echarts实现两个y轴0刻度保持一致（多条数据时）" class="headerlink" title="echarts实现两个y轴0刻度保持一致（多条数据时）"></a>echarts实现两个y轴0刻度保持一致（多条数据时）</h2><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>当一个图表有两个y轴的时候，而且其中一个出现负数时，会出现下面这种情况，可能两个y轴的0刻度线不保持一致</p><p>而为了美观，则需要放到同一刻度线，这里就需要自己写方法了</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240327093758999.png" alt="image-20240327093758999"></p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240327093829777.png" alt="image-20240327093829777"></p><h4 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h4><p>网上方法较多，但是相比于实际情况还是有些差别，这里是参考了<a href="https://blog.csdn.net/qq_32862143/article/details/112969310">这位大佬</a>的方法</p><p><strong>1.求出左右y轴的最大值最小值，这里是对多条数据遍历，yAxisIndex代表不同y轴</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> result = &#123;&#125;;<br>     allData.forEach(item =&gt; &#123;<br>       const yAxisIndex = item.yAxisIndex;<br>       const <span class="hljs-built_in">values</span> = item.data.<span class="hljs-built_in">map</span>(value =&gt; parseInt(value));<br>       <span class="hljs-keyword">if</span> (!result[yAxisIndex]) &#123;<br>         result[yAxisIndex] = &#123;<br>           <span class="hljs-built_in">max</span>: Math.<span class="hljs-built_in">max</span>(...<span class="hljs-built_in">values</span>),<br>           <span class="hljs-built_in">min</span>: Math.<span class="hljs-built_in">min</span>(...<span class="hljs-built_in">values</span>)<br>         &#125;;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         result[yAxisIndex].<span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(result[yAxisIndex].<span class="hljs-built_in">max</span>, ...<span class="hljs-built_in">values</span>);<br>         result[yAxisIndex].<span class="hljs-built_in">min</span> = Math.<span class="hljs-built_in">min</span>(result[yAxisIndex].<span class="hljs-built_in">min</span>, ...<span class="hljs-built_in">values</span>);<br>       &#125;<br>     &#125;);<br></code></pre></td></tr></table></figure><p><strong>2.如果最小值不小于零 直接不做处理</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">       <span class="hljs-type">const</span> max1 = result[<span class="hljs-number">0</span>].max || <span class="hljs-number">1</span>;<br>        <span class="hljs-type">const</span> min1 = result[<span class="hljs-number">0</span>].min || <span class="hljs-number">0</span>;<br>        <span class="hljs-type">const</span> max2 = result[<span class="hljs-number">1</span>].max || <span class="hljs-number">1</span>;<br>        <span class="hljs-type">const</span> min2 = result[<span class="hljs-number">1</span>].min || <span class="hljs-number">0</span>;<br><span class="hljs-comment">//不小于零直接不需要处理</span><br>        <span class="hljs-keyword">if</span> (min1 &gt;= <span class="hljs-number">0</span> || min2 &gt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>3.算出刻度比例</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">const ratio <span class="hljs-operator">=</span> (<span class="hljs-keyword">max</span><span class="hljs-number">1</span> - <span class="hljs-keyword">min</span><span class="hljs-number">1</span>) / (<span class="hljs-keyword">max</span><span class="hljs-number">2</span> - <span class="hljs-keyword">min</span><span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>4.判断哪使用哪个y轴 并将对应的比例相乘</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let minMax <span class="hljs-operator">=</span> &#123;&#125;<br>if (max1 &lt; max2 * ratio) &#123;<br>  minMax.y1Max <span class="hljs-operator">=</span> max2 * ratio<span class="hljs-comment">;</span><br>  minMax.y2Max <span class="hljs-operator">=</span> max2<span class="hljs-comment">;</span><br>&#125; else &#123;<br>  minMax.y1Max <span class="hljs-operator">=</span> max1<span class="hljs-comment">;</span><br>  minMax.y2Max <span class="hljs-operator">=</span> max1 / ratio<span class="hljs-comment">;</span><br>&#125;<br>if (min1 &lt; min2 * ratio) &#123;<br>  minMax.y1Min <span class="hljs-operator">=</span> min1<span class="hljs-comment">;</span><br>  minMax.y2Min <span class="hljs-operator">=</span> min1 / ratio<span class="hljs-comment">;</span><br>&#125; else &#123;<br>  minMax.y1Min <span class="hljs-operator">=</span> min2 * ratio<span class="hljs-comment">;</span><br>  minMax.y2Min <span class="hljs-operator">=</span> min2<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.扩大最大值最小值</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">minMax</span>.y1Min = (minMax.y1Min * <span class="hljs-number">1</span>.<span class="hljs-number">5</span>).toFixed(<span class="hljs-number">0</span>)<br>        <span class="hljs-attribute">minMax</span>.y2Min = (minMax.y2Min * <span class="hljs-number">1</span>.<span class="hljs-number">5</span>).toFixed(<span class="hljs-number">0</span>)<br>        <span class="hljs-attribute">minMax</span>.y1Max = (minMax.y1Max * <span class="hljs-number">1</span>.<span class="hljs-number">5</span>).toFixed(<span class="hljs-number">0</span>)<br>        <span class="hljs-attribute">minMax</span>.y2Max = (minMax.y2Max * <span class="hljs-number">1</span>.<span class="hljs-number">5</span>).toFixed(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>6.赋值，这里需要做下判断如果不没有小于零的负数直接依然使用默认最大值最小值</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs arcade">yAxis：&#123;<br>           <span class="hljs-attr">max</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>             const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>             <span class="hljs-keyword">if</span> (minMax) &#123;<br>               <span class="hljs-keyword">return</span> minMax.y1Max<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br>             &#125;<br>           &#125;,<br>           <span class="hljs-attr">min</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>             const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>             <span class="hljs-keyword">if</span> (minMax) &#123;<br>               <span class="hljs-keyword">return</span> minMax.y1Min<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span><br>             &#125;<br>           &#125;<br>         &#125;, &#123;<br>           <span class="hljs-attr">max</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>             const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>             <span class="hljs-keyword">if</span> (minMax) &#123;<br>               <span class="hljs-keyword">return</span> minMax.y2Max<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br>             &#125;<br>           &#125;,<br>           <span class="hljs-attr">min</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>             const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>             <span class="hljs-keyword">if</span> (minMax) &#123;<br>               <span class="hljs-keyword">return</span> minMax.y2Min<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span><br>             &#125;<br>           &#125;<br>         &#125;<br></code></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs awk">maintainScale(allData) &#123;<br>     <span class="hljs-regexp">//</span>       const allData = [<br>     <span class="hljs-regexp">//</span>     &#123;<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;data&quot;</span>: [<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;6083&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;310&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;355&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;2721&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;14&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;1835&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;64&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;-1&quot;</span><br>     <span class="hljs-regexp">//</span>         ],<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;yAxisIndex&quot;</span>: <span class="hljs-number">0</span>,<br>     <span class="hljs-regexp">//</span>     &#125;,<br>     <span class="hljs-regexp">//</span>     &#123;<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;data&quot;</span>: [<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;5298&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;241&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;347&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;1899&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;7&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;1611&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;43&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;4&quot;</span><br>     <span class="hljs-regexp">//</span>         ],<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;yAxisIndex&quot;</span>: <span class="hljs-number">0</span>,<br>     <span class="hljs-regexp">//</span>     &#125;,<br>     <span class="hljs-regexp">//</span>     &#123;<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;data&quot;</span>: [<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;396&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;2644&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;2152&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;131&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;5&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;3357&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;61&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;200&quot;</span><br>     <span class="hljs-regexp">//</span>         ],<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;yAxisIndex&quot;</span>: <span class="hljs-number">1</span>,<br>     <span class="hljs-regexp">//</span>     &#125;,<br>     <span class="hljs-regexp">//</span>     &#123;<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;data&quot;</span>: [<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;344&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;1890&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;1890&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;101&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;4&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;2524&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;96&quot;</span>,<br>     <span class="hljs-regexp">//</span>             <span class="hljs-string">&quot;203&quot;</span><br>     <span class="hljs-regexp">//</span>         ],<br>     <span class="hljs-regexp">//</span>         <span class="hljs-string">&quot;yAxisIndex&quot;</span>: <span class="hljs-number">1</span>,<br>     <span class="hljs-regexp">//</span>     &#125;<br>     <span class="hljs-regexp">//</span> ];<br>     let result = &#123;&#125;;<br>     allData.forEach(item =&gt; &#123;<br>       const yAxisIndex = item.yAxisIndex;<br>       const values = item.data.map(value =&gt; parseInt(value));<br>       <span class="hljs-keyword">if</span> (!result[yAxisIndex]) &#123;<br>         result[yAxisIndex] = &#123;<br>           max: Math.max(...values),<br>           min: Math.min(...values)<br>         &#125;;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         result[yAxisIndex].max = Math.max(result[yAxisIndex].max, ...values);<br>         result[yAxisIndex].min = Math.min(result[yAxisIndex].min, ...values);<br>       &#125;<br>     &#125;);<br>     console.log(result);<br>     <span class="hljs-keyword">if</span> (Object.keys(result).length == <span class="hljs-number">2</span>) &#123;<br>       const max1 = result[<span class="hljs-number">0</span>].max || <span class="hljs-number">1</span>;<br>       const min1 = result[<span class="hljs-number">0</span>].min || <span class="hljs-number">0</span>;<br>       const max2 = result[<span class="hljs-number">1</span>].max || <span class="hljs-number">1</span>;<br>       const min2 = result[<span class="hljs-number">1</span>].min || <span class="hljs-number">0</span>;<br>       <span class="hljs-regexp">//</span>不小于零直接不需要处理<br>       <span class="hljs-keyword">if</span> (min1 &gt;= <span class="hljs-number">0</span> || min2 &gt;= <span class="hljs-number">0</span>) &#123;<br>         return false<br>       &#125;<br>       const ratio = (max1 - min1) / (max2 - min2);<br>       let minMax = &#123;&#125;<br>       <span class="hljs-keyword">if</span> (max1 &lt; max2 * ratio) &#123;<br>         minMax.y1Max = max2 * ratio;<br>         minMax.y2Max = max2;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         minMax.y1Max = max1;<br>         minMax.y2Max = max1 / ratio;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (min1 &lt; min2 * ratio) &#123;<br>         minMax.y1Min = min1;<br>         minMax.y2Min = min1 / ratio;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         minMax.y1Min = min2 * ratio;<br>         minMax.y2Min = min2;<br>       &#125;<br>       minMax.y1Min = (minMax.y1Min * <span class="hljs-number">1.5</span>).toFixed(<span class="hljs-number">0</span>)<br>       minMax.y2Min = (minMax.y2Min * <span class="hljs-number">1.5</span>).toFixed(<span class="hljs-number">0</span>)<br>       minMax.y1Max = (minMax.y1Max * <span class="hljs-number">1.5</span>).toFixed(<span class="hljs-number">0</span>)<br>       minMax.y2Max = (minMax.y2Max * <span class="hljs-number">1.5</span>).toFixed(<span class="hljs-number">0</span>)<br>       return minMax<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       return false<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>调用方法再将minMax赋值即可</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let minMax = this.maintainScale(newSeriesData)<br>...<br>  yAxis：&#123;<br>            ...<br>            <br>            <span class="hljs-built_in">max</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>              const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>              <span class="hljs-keyword">if</span> (minMax) &#123;<br>                <span class="hljs-keyword">return</span> minMax.y1Max<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br>              &#125;<br>            &#125;,<br>            <span class="hljs-attr">min</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>              const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>              <span class="hljs-keyword">if</span> (minMax) &#123;<br>                <span class="hljs-keyword">return</span> minMax.y1Min<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span><br>              &#125;<br>            &#125;,<br>            ...<br>          &#125;, <br>          &#123;<br>            ...<br>            <span class="hljs-built_in">max</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>              const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>              <span class="hljs-keyword">if</span> (minMax) &#123;<br>                <span class="hljs-keyword">return</span> minMax.y2Max<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br>              &#125;<br>            &#125;,<br>            <span class="hljs-attr">min</span>: <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>              const &#123; <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> &#125; = value;<br>              <span class="hljs-keyword">if</span> (minMax) &#123;<br>                <span class="hljs-keyword">return</span> minMax.y2Min<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span><br>              &#125;<br>            &#125;,<br>            ...<br>          &#125;<br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Echarts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Echarts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>淘宝镜像过期（certificate has expired）</title>
    <link href="/Tian-1-2/typblog/2024/02/01/202421-%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E8%BF%87%E6%9C%9F%EF%BC%88certificate-has-expired%EF%BC%89/"/>
    <url>/Tian-1-2/typblog/2024/02/01/202421-%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E8%BF%87%E6%9C%9F%EF%BC%88certificate-has-expired%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="npm-ERR-request-to-https-registry-npm-taobao-org-yauzl-yauzl-2-4-1-tgz-failed-reason-certificate-has-expired"><a href="#npm-ERR-request-to-https-registry-npm-taobao-org-yauzl-yauzl-2-4-1-tgz-failed-reason-certificate-has-expired" class="headerlink" title="npm ERR! request to https://registry.npm.taobao.org/yauzl/-/yauzl-2.4.1.tgz failed, reason: certificate has expired"></a>npm ERR! request to <a href="https://registry.npm.taobao.org/yauzl/-/yauzl-2.4.1.tgz">https://registry.npm.taobao.org/yauzl/-/yauzl-2.4.1.tgz</a> failed, reason: certificate has expired</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/848ee4ebd15e4ed49f67f9a9c578fafa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=96&s=14066&e=png&b=1e1e1e" alt="image.png"></p><p>今天在执行 npm install 命令时，报错百度了下是淘宝证书过期原因</p><h4 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h4><p>执行下面两个命令再进行 npm install 即可</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm cache clean --force<br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> strict-ssl <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>npm cache clean –force</strong></p><p>这个命令用于清除 npm 的缓存。npm 在安装包时会将下载的包缓存到本地，以便下次使用时可以直接从缓存中获取，加快安装速度。使用 npm cache clean 可以清除缓存，而 –force 参数表示强制清除缓存，即使有其他进程正在使用缓存。</p><p><strong>npm config set strict-ssl false</strong></p><p>用于配置 npm 的 SSL 严格模式。默认情况下，npm 在下载包时会验证 SSL 证书的有效性，以确保安全性。通过设置 strict-ssl 为 false，可以禁用 SSL 严格模式，允许使用自签名或无效的 SSL 证书进行下载，此方法就会忽略淘宝证书过期</p><h4 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h4><p>直接更换镜像源，这里举例更换阿里源</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//npm.aliyun.com/</span><br></code></pre></td></tr></table></figure><p>国内的镜像源还有很多，大家百度查询即可</p><p>这里列举一下</p><p>腾讯:<a href="http://mirrors.cloud.tencent.com/npm/">http://mirrors.cloud.tencent.com/npm/</a></p><p>华为：<a href="https://mirrors.huaweicloud.com/repository/npm/">https://mirrors.huaweicloud.com/repository/npm/</a></p><p>中科大镜像:<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><p>另一个淘宝镜像：<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度地图打点性能优化（海量点、mapv）</title>
    <link href="/Tian-1-2/typblog/2024/01/06/202416-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%89%93%E7%82%B9%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E6%B5%B7%E9%87%8F%E7%82%B9%E3%80%81mapv%EF%BC%89/"/>
    <url>/Tian-1-2/typblog/2024/01/06/202416-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%89%93%E7%82%B9%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E6%B5%B7%E9%87%8F%E7%82%B9%E3%80%81mapv%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="百度地图打点性能优化（海量点、mapv）"><a href="#百度地图打点性能优化（海量点、mapv）" class="headerlink" title="百度地图打点性能优化（海量点、mapv）"></a>百度地图打点性能优化（海量点、mapv）</h2><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>在百度地图api中，默认的点是下图的红点</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240106174156171.png" alt="image-20240106174156171"></p><p>而这种点位比较多的时候，就会出现加载卡顿问题</p><h5 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h5><p>想要进行方法优化，首先需要分析其原因。</p><h6 id="数据获取方面"><a href="#数据获取方面" class="headerlink" title="数据获取方面"></a>数据获取方面</h6><p>数据量比较庞大时，我们采用了分批调用获取的方法，采用异步的方式，可以利用await进行调用接口数据，这里是为了减轻服务端压力，把庞大的数据分批进行返回。</p><h6 id="页面加载方面"><a href="#页面加载方面" class="headerlink" title="页面加载方面"></a>页面加载方面</h6><p>渲染时为什么会出现卡顿现象，检查可以看出其原因</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240106174934686.png" alt="image-20240106174934686"></p><p>这是一个个dom结构，当海量数据同事渲染时，这里就涉及到大量的dom操作，造成重绘或重排，从而造成卡顿问题，所以解决问题的方法就是减少dom操作。</p><p>其中一种解决方法就是转化为canvas,canvas操作相对于DOM操作资源消耗较少，因为canvas操作是基于像素的绘制操作，不涉及到浏览器的解析和渲染过程。</p><p>而且百度地图在JavaScript API v3.0中给出了相应的解决方案 PointCollection属性</p><p>官方解释如下</p><p><strong>PointCollection</strong></p><p>此类表示海量点类，利用该类可同时在地图上展示万级别的点，目前仅适用于html5浏览器。</p><table><thead><tr><th>构造函数</th><th>描述</th></tr></thead><tbody><tr><td>PointCollection(points: Array<Point>, opts: PointCollectionOptions)</td><td>创建海量点类。points为点的坐标集合，opts为点的绘制样式</td></tr></tbody></table><table><thead><tr><th>方法</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>setPoints(points: Array<Point>)</td><td>none</td><td>设置要在地图上展示的点坐标集合</td></tr><tr><td>setStyles(styles: PointCollectionOption)</td><td>none</td><td>点的样式，包括:大小”size”（可选,默认正常尺寸10*10px，SizeType类型），形状”shape”（可选，默认圆形，ShapeType类型），颜色”color”（可选，字符串类型）</td></tr><tr><td>clear()</td><td>none</td><td>清除海量点</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><table><thead><tr><th>事件</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>click</td><td>event{type, target,point}</td><td>鼠标点击点时会触发此事件</td></tr><tr><td>mouseover</td><td>event{type, target,point}</td><td>鼠标移入点时会触发该事件</td></tr><tr><td>mouseout</td><td>event{type, target,point}</td><td>鼠标移出点时会触发该事件</td></tr></tbody></table><p>而该海量点就是将百度地图转化为canvas,使用该api可以解决卡顿效果，但是又有一些缺陷</p><p><strong>兼容问题</strong></p><p>某些浏览器不支持canvas绘制，这里就要做一个判断，通过下面代码判断是否能绘制即可</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">document.create<span class="hljs-constructor">Element(<span class="hljs-string">&quot;canvas&quot;</span>)</span>.get<span class="hljs-constructor">Context(<span class="hljs-string">&quot;2d&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>下面是对支持canvas的浏览器以及版本供参考</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240106183151653.png" alt="image-20240106183151653"></p><p><strong>样式问题</strong></p><p>海量点api中，它的样式是固定选择的几个，通过PointCollectionOptions中的ShapeType属性定义</p><p>官网给的几个形状如下</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>BMAP_POINT_SHAPE_CIRCLE</td><td>圆形，为默认形状</td></tr><tr><td>BMAP_POINT_SHAPE_STAR</td><td>星形</td></tr><tr><td>BMAP_POINT_SHAPE_SQUARE</td><td>方形</td></tr><tr><td>BMAP_POINT_SHAPE_RHOMBUS</td><td>菱形</td></tr><tr><td>BMAP_POINT_SHAPE_WATERDROP</td><td>水滴状，该类型无size和color属性属性定义</td></tr></tbody></table><p>这几个形状说实话在地图上不是太好看。。。</p><p>如果UI对标点样式没有要求，皆大欢喜，不用再做处理了，但非要进行改正，这就需要换另一种处理方法了</p><p>这里百度地图也推荐了一种处理方法——<strong>Mapv</strong></p><p><strong>Mapv</strong></p><p>Mapv 是一款地理信息可视化开源库，可以用来展示大量地理信息数据，点、线、面的数据，每种数据也有不同的展示类型，如直接打点、热力图、网格、聚合等方式展示数据，其也是将地图绘制成canvas</p><p>官网：<a href="https://mapv.baidu.com/">https://mapv.baidu.com/</a></p><p>GitHub：<a href="https://github.com/huiyan-fe/mapv">https://github.com/huiyan-fe/mapv</a></p><p>在这里可以自定义标点图标，下面是举例设置图标的地方</p><p>示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs prolog">var data = [<br>    // 点数据<br>    &#123;<br>        geometry: &#123;<br>            type: <span class="hljs-string">&#x27;Point&#x27;</span>,<br>            coordinates: [<span class="hljs-number">123</span>, <span class="hljs-number">23</span>]<br>        &#125;,<br>        fillStyle: <span class="hljs-string">&#x27;red&#x27;</span>,<br>         // 支持image对象和url两种方式<br>        icon: [img, <span class="hljs-string">&#x27;images/marker.png&#x27;</span>, <span class="hljs-string">&#x27;images/star.png&#x27;</span>][randomCount <span class="hljs-comment">% 3],</span><br>        size: <span class="hljs-number">30</span><br>    &#125;,<br>    &#123;<br>        geometry: &#123;<br>            type: <span class="hljs-string">&#x27;Point&#x27;</span>,<br>            coordinates: [<span class="hljs-number">121</span>, <span class="hljs-number">33</span>]<br>        &#125;,<br>        fillStyle: <span class="hljs-string">&#x27;rgba(255, 255, 50, 0.5)&#x27;</span>,<br>        size: <span class="hljs-number">90</span><br>    &#125;,<br>    // 线数据<br>    &#123;<br>        geometry: &#123;<br>            type: <span class="hljs-string">&#x27;LineString&#x27;</span>,<br>            coordinates: [<br>                [<span class="hljs-number">123</span>, <span class="hljs-number">23</span>], <br>                [<span class="hljs-number">124</span>, <span class="hljs-number">24</span>]<br>            ]<br>        &#125;,<br>        count: <span class="hljs-number">30</span><br>    &#125;,<br>    // 面数据<br>    &#123;<br>        geometry: &#123;<br>            type: <span class="hljs-string">&#x27;Polygon&#x27;</span>,<br>            coordinates: [<br>                [<br>                    [<span class="hljs-number">123</span>, <span class="hljs-number">23</span>], <br>                    [<span class="hljs-number">123</span>, <span class="hljs-number">23</span>], <br>                    [<span class="hljs-number">123</span>, <span class="hljs-number">23</span>]<br>                ]<br>            ]<br>        &#125;,<br>        count: <span class="hljs-number">30</span> * <span class="hljs-symbol">Math</span>.random()<br>    &#125;<br>];<br><br>var dataSet = new mapv.<span class="hljs-symbol">DataSet</span>(data);<br></code></pre></td></tr></table></figure><p>这里data中的属性配置项官方文档是这样描述的</p><p>mapv中主要都是展示地理信息数据用的，需要在数据中加个geometry字段，geometry字段的内容统一使用<a href="http://geojson.org/">Geojson</a>的规范，大家自行查阅资料配置即可。</p><p>这里只是一个简单示例，具体实现参考官方文档</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://lbsyun.baidu.com/index.php?title=jspopular3.0">百度地图jsapi v3</a></p><p><a href="https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_reference_3_0.html#a3b20">jsapi v3类参考文档</a></p><p><a href="https://mapv.baidu.com/">mapv官网</a></p><p><a href="https://github.com/huiyan-fe/mapv/blob/master/API.md">mapv官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义Echarts中legend、tooltip等样式</title>
    <link href="/Tian-1-2/typblog/2024/01/04/202414-%E8%87%AA%E5%AE%9A%E4%B9%89Echarts%E4%B8%ADlegend%E3%80%81tooltip%E7%AD%89%E6%A0%B7%E5%BC%8F/"/>
    <url>/Tian-1-2/typblog/2024/01/04/202414-%E8%87%AA%E5%AE%9A%E4%B9%89Echarts%E4%B8%ADlegend%E3%80%81tooltip%E7%AD%89%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="自定义Echarts中legend、tooltip等样式"><a href="#自定义Echarts中legend、tooltip等样式" class="headerlink" title="自定义Echarts中legend、tooltip等样式"></a>自定义Echarts中legend、tooltip等样式</h2><p>在使用Echarts图表中不可避免的要定义legend、tooltip中的样式，这里以legend为例介绍一下通用的方法</p><p>先介绍一下用到的属性</p><h5 id="legend-formatter"><a href="#legend-formatter" class="headerlink" title="legend.formatter"></a>legend.formatter</h5><p>用来格式化图例文本，支持字符串模板和回调函数两种形式。</p><p>示例：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 使用字符串模板，模板变量为图例名称 &#123;name&#125;</span><br>formatter: <span class="hljs-string">&#x27;Legend &#123;name&#125;&#x27;</span><br><span class="hljs-comment">// 使用回调函数</span><br>formatter: <span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Legend &#x27;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="legend-textStyle"><a href="#legend-textStyle" class="headerlink" title="legend. textStyle"></a>legend. textStyle</h5><p>图例的公用文本样式，在这可以设置legend的整体样式，有多种属性进行选择，可以在官方文档进行查看，这里不一一介绍了</p><p>重要介绍的是其子属性rich</p><h5 id="legend-textStyle-rich"><a href="#legend-textStyle-rich" class="headerlink" title="legend.textStyle. rich"></a>legend.textStyle. rich</h5><p>官方解释如下</p><p>在 rich 里面，可以自定义富文本样式。利用富文本样式，可以在标签中做出非常丰富的效果。</p><p>例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">label: &#123;<br>    <span class="hljs-regexp">//</span> 在文本中，可以对部分文本采用 rich 中定义样式。<br>    <span class="hljs-regexp">//</span> 这里需要在文本中使用标记符号：<br>    <span class="hljs-regexp">//</span> `&#123;styleName|text content text content&#125;` 标记样式名。<br>    <span class="hljs-regexp">//</span> 注意，换行仍是使用 <span class="hljs-string">&#x27;\n&#x27;</span>。<br>    formatter: [<br>        <span class="hljs-string">&#x27;&#123;a|这段文本采用样式a&#125;&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#123;b|这段文本采用样式b&#125;这段用默认样式&#123;x|这段用样式x&#125;&#x27;</span><br>    ].join(<span class="hljs-string">&#x27;\n&#x27;</span>),<br><br>    rich: &#123;<br>        a: &#123;<br>            color: <span class="hljs-string">&#x27;red&#x27;</span>,<br>            lineHeight: <span class="hljs-number">10</span><br>        &#125;,<br>        b: &#123;<br>            backgroundColor: &#123;<br>                image: <span class="hljs-string">&#x27;xxx/xxx.jpg&#x27;</span><br>            &#125;,<br>            height: <span class="hljs-number">40</span><br>        &#125;,<br>        x: &#123;<br>            fontSize: <span class="hljs-number">18</span>,<br>            fontFamily: <span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>,<br>            borderColor: <span class="hljs-string">&#x27;#449933&#x27;</span>,<br>            borderRadius: <span class="hljs-number">4</span><br>        &#125;,<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官方解释已经很明了，接下来直接看实例</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>这里是一个扇形图</p><p>直接上代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">option</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">title:</span> &#123;<br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&#x27;Referer of a Website&#x27;</span>,<br>    <span class="hljs-attr">subtext:</span> <span class="hljs-string">&#x27;Fake Data&#x27;</span>,<br>    <span class="hljs-attr">left:</span> <span class="hljs-string">&#x27;center&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">tooltip:</span> &#123;<br>    <span class="hljs-attr">trigger:</span> <span class="hljs-string">&#x27;item&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">legend:</span> &#123;<br>    <span class="hljs-attr">orient:</span> <span class="hljs-string">&#x27;vertical&#x27;</span>,<br>    <span class="hljs-attr">left:</span> <span class="hljs-string">&#x27;left&#x27;</span>,<br>    <span class="hljs-attr">formatter:</span> [<span class="hljs-string">&#x27;&#123;ttt|这段文本采用样式a&#125;&#x27;</span>,<br>              <span class="hljs-string">&#x27;&#123;b|这段文本采用样式b&#125;&#x27;</span>,<br>              <span class="hljs-string">&#x27;&#123;这段用默认样式&#125;&#x27;</span>,<br>              <span class="hljs-string">&#x27;&#123;x|这段用样式x&#125;&#x27;</span>]<span class="hljs-string">.join(&#x27;\n&#x27;)</span>,<br>    <span class="hljs-string">textStyle:</span>&#123;<br>      <span class="hljs-attr">padding:</span> [<span class="hljs-number">60</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>       <span class="hljs-attr">rich:</span> &#123;<br>        <span class="hljs-attr">ttt:</span> &#123;<br>            <span class="hljs-attr">color:</span> <span class="hljs-string">&#x27;red&#x27;</span>,<br>            <span class="hljs-attr">lineHeight:</span> <span class="hljs-number">20</span>,<br>            <br>        &#125;,<br>        <span class="hljs-attr">b:</span> &#123;<br>            <span class="hljs-attr">backgroundColor:</span> &#123;<br>                <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;xxx/xxx.jpg&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">height:</span> <span class="hljs-number">40</span><br>        &#125;,<br>        <span class="hljs-attr">x:</span> &#123;<br>            <span class="hljs-attr">fontSize:</span> <span class="hljs-number">18</span>,<br>            <span class="hljs-attr">fontFamily:</span> <span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>,<br>            <span class="hljs-attr">borderColor:</span> <span class="hljs-string">&#x27;#449933&#x27;</span>,<br>            <span class="hljs-attr">borderRadius:</span> <span class="hljs-number">4</span><br>        &#125;,<br>      &#125;<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">series:</span> [<br>    &#123;<br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Access From&#x27;</span>,<br>      <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;pie&#x27;</span>,<br>      <span class="hljs-attr">radius:</span> <span class="hljs-string">&#x27;50%&#x27;</span>,<br>      <span class="hljs-attr">data:</span> [<br>        &#123; <span class="hljs-attr">value:</span> <span class="hljs-number">1048</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Search Engine&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">value:</span> <span class="hljs-number">735</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Direct&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">value:</span> <span class="hljs-number">580</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Email&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">value:</span> <span class="hljs-number">484</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Union Ads&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">value:</span> <span class="hljs-number">300</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Video Ads&#x27;</span> &#125;<br>      ],<br>      <span class="hljs-attr">emphasis:</span> &#123;<br>        <span class="hljs-attr">itemStyle:</span> &#123;<br>          <span class="hljs-attr">shadowBlur:</span> <span class="hljs-number">10</span>,<br>          <span class="hljs-attr">shadowOffsetX:</span> <span class="hljs-number">0</span>,<br>          <span class="hljs-attr">shadowColor:</span> <span class="hljs-string">&#x27;rgba(0, 0, 0, 0.5)&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><h5 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h5><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20240104203935142.png" alt="image-20240104203935142"></p><h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><p><a href="https://echarts.apache.org/zh/option.html#legend">echarts官网</a></p>]]></content>
    
    
    <categories>
      
      <category>Echarts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Echarts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Echarts小问题汇总</title>
    <link href="/Tian-1-2/typblog/2023/12/12/20231212-Echarts%E5%B0%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/Tian-1-2/typblog/2023/12/12/20231212-Echarts%E5%B0%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Echarts小问题汇总"><a href="#Echarts小问题汇总" class="headerlink" title="Echarts小问题汇总"></a>Echarts小问题汇总</h2><p>记录工作中使用Echarts的遇见的一些小问题，后续会不断进行补充</p><h5 id="1-柱状图第一条柱子遮挡Y轴解决方法"><a href="#1-柱状图第一条柱子遮挡Y轴解决方法" class="headerlink" title="1.柱状图第一条柱子遮挡Y轴解决方法"></a>1.柱状图第一条柱子遮挡Y轴解决方法</h5><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20231212200738960.png" alt="image-20231212200738960"></p><p>这个是echarts两边没有留白导致的第一个和最后一个遮挡Y轴，</p><p>在你的echarts 配置项中大概率出现了 boundaryGap：false这条属性，这个属性在折线图中没有任何问题，但是在柱状图中就会出现这种情况，可以把这条属性注解掉或者把false修改为true就可以解决柱状图遮挡Y轴问题。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">xAxis: &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;category&#x27;</span>,<br>    boundaryGap:<span class="hljs-literal">true</span>,<br>    <span class="hljs-built_in">data</span>: <span class="hljs-meta">[</span><span class="hljs-string">&#x27;Mon&#x27;</span>, <span class="hljs-string">&#x27;Tue&#x27;</span>, <span class="hljs-string">&#x27;Wed&#x27;</span>, <span class="hljs-string">&#x27;Thu&#x27;</span>, <span class="hljs-string">&#x27;Fri&#x27;</span>, <span class="hljs-string">&#x27;Sat&#x27;</span>, <span class="hljs-string">&#x27;Sun&#x27;</span><span class="hljs-meta">]</span><br>  &#125;,<br></code></pre></td></tr></table></figure><h5 id="2-在大屏渲染后-拖到小屏变模糊"><a href="#2-在大屏渲染后-拖到小屏变模糊" class="headerlink" title="2.在大屏渲染后 拖到小屏变模糊"></a>2.在大屏渲染后 拖到小屏变模糊</h5><p>这是因为初始化时是根据当前屏幕进行渲染的，如何拖动到其他屏幕可能分辨率不同导致显示模糊（后续做详细介绍）。</p><p>解决方法可以刷新就可以，或者换种代码渲染方式，采用svg渲染</p><p>初始化代码时传入{renderer:’svg’}参数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> myChart = echarts.<span class="hljs-keyword">init</span>(document.getElementById(<span class="hljs-string">&#x27;main&#x27;</span>), <span class="hljs-literal">null</span>, &#123;renderer:<span class="hljs-string">&#x27;svg&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-相邻柱状图中间不要有空隙"><a href="#3-相邻柱状图中间不要有空隙" class="headerlink" title="3.相邻柱状图中间不要有空隙"></a>3.相邻柱状图中间不要有空隙</h5><p>默认的柱状图之间纯在间隙</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20231212201519430.png" alt="image-20231212201519430"></p><p>解决方法：在series中加入barGap:’0%’即可</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">series</span>: [<br>  &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>: [120, 200, 150, 80, 70, 110, 130],</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;,</span><br>    barGap: &#x27;<span class="hljs-number">0</span>%&#x27;,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>: [120, 200, 150, 80, 70, 110, 130],</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;</span><br>  &#125;,&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>: [120, 200, 150, 80, 70, 110, 130],</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;</span><br>  &#125;,&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>: [120, 200, 150, 80, 70, 110, 130],</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;</span><br>  &#125;,&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>: [120, 200, 150, 80, 70, 110, 130],</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20231212201757209.png" alt="image-20231212201757209"></p><h5 id="4-实现echarts图表自适应"><a href="#4-实现echarts图表自适应" class="headerlink" title="4.实现echarts图表自适应"></a>4.实现echarts图表自适应</h5><p>echarts自带的有resize()方法，官方解释用处为：改变图表尺寸，在容器大小发生改变时需要手动调用，所以我们监听屏幕变化时调用方法即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> echartDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;echart&#x27;</span>);<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">echartElement</span> = echarts.<span class="hljs-title function_">init</span>(echartDom);<br>   <span class="hljs-comment">// 页面大小变化重置图表</span><br>   <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">echartElement</span>.<span class="hljs-title function_">resize</span>();<br>   &#125;);<br> &#125;,<br> <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">echartElement</span>.<span class="hljs-title function_">resize</span>();<br>   &#125;);<br> &#125;,<br></code></pre></td></tr></table></figure><p>销毁组件中别忘记去除监听</p><h5 id="5-单个柱状图最大宽度"><a href="#5-单个柱状图最大宽度" class="headerlink" title="5.单个柱状图最大宽度"></a>5.单个柱状图最大宽度</h5><p>当数据变少时，因为其自适应效果，但列时会撑满，柱子变的很粗，不太美观</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20231212202606596.png" alt="image-20231212202606596"></p><p>在series中加入barMaxWidth属性即可</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">series</span>: [<br>    &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">data</span>: [120,</span><br>      <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;,</span><br>      barGap: &#x27;<span class="hljs-number">0</span>%&#x27;,<br>      barMaxWidth:<span class="hljs-number">20</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">data</span>: [120],</span><br>      <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;,</span><br>      barMaxWidth:<span class="hljs-number">20</span>,<br>    &#125;,&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">data</span>: [120],</span><br>      <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;,</span><br>      barMaxWidth:<span class="hljs-number">20</span>,<br>    &#125;,&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">data</span>: [120],</span><br>      <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;,</span><br>      barMaxWidth:<span class="hljs-number">20</span>,<br>    &#125;,&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">data</span>: [120],</span><br>      <span class="hljs-class"><span class="hljs-keyword">type</span>: &#x27;bar&#x27;,</span><br>      barMaxWidth:<span class="hljs-number">20</span>,<br>    &#125;<br>  ]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20231212202955081.png" alt="image-20231212202955081"></p>]]></content>
    
    
    <categories>
      
      <category>Echarts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Echarts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应届裁员，天胡开局——谈谈我的前端一年经历</title>
    <link href="/Tian-1-2/typblog/2023/11/14/20231114-%E5%BA%94%E5%B1%8A%E8%A3%81%E5%91%98%EF%BC%8C%E5%A4%A9%E8%83%A1%E5%BC%80%E5%B1%80%E2%80%94%E2%80%94%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B8%80%E5%B9%B4%E7%BB%8F%E5%8E%86/"/>
    <url>/Tian-1-2/typblog/2023/11/14/20231114-%E5%BA%94%E5%B1%8A%E8%A3%81%E5%91%98%EF%BC%8C%E5%A4%A9%E8%83%A1%E5%BC%80%E5%B1%80%E2%80%94%E2%80%94%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B8%80%E5%B9%B4%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="应届裁员，天胡开局——谈谈我的前端一年经历"><a href="#应届裁员，天胡开局——谈谈我的前端一年经历" class="headerlink" title="应届裁员，天胡开局——谈谈我的前端一年经历"></a>应届裁员，天胡开局——谈谈我的前端一年经历</h3><p>许久没有更新了，最近一个月都在忙，没错，正如题目所说，裁员然后找工作……</p><p>这周刚重新上班，工作第二天，感慨良多，记录些什么吧。</p><p>去年十月，拿到第一个实习offer，只身前往南京，开始了自己的前端职业生涯。期待又惶恐。所幸公司很nice，公司氛围很不错，带我的大哥来的第一天还请我吃了顿饭，很是感激。业务上前辈们对我也很有耐心，我工作了一个月，压力也不是很大。以现在的角度来看是一个非常棒的公司，可是我还是因为我个人问题很快就离职了。还记得当时的leader一直在劝我，也有好多朋友劝我不要离职，最终自己还是执意离职了。</p><p>离职后第二天我就回到了学习的地方，重新准备，看面试题、投简历……</p><p>这次有了实习经历后找工作似乎格外的顺，当时一周面试的应该有十多场，当时还正值疫情爆发，每天偷摸跑办公室去面试，拿到了4个offer。然后这似乎又是一次决定命运的选择。有三家上海的，一家北京的，其中上海有一家公司也算是个中型的科技公司，当时的一面面试官是老乡，二面技术总监聊的也很愉快，技术栈用react，会给我足够的时间来学习，当时我也很想学react，对这家印象很好。可是后来却去了北京这家公司，就是我上家公司了。</p><p>北京这家是创业公司，刚成立不到一年，当时也没想那么多会不会倒闭什么的，面试的时候老板也很随和，当时主要一个心也是去北京，想在北京发展，薪资方面也挺不错。所以经过考虑还是去北京了。</p><p>当时是十二月疫情正全面爆发，所以我一直居家办公，老板人很好，我过年后才去北京。到了北京又工作了一个月实习期结束，和老板正式谈转正薪资，给了一个非常满意的薪资。当时非常激动，终于要迎来自己的第一份正式工作了，当时还发了个朋友圈</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231114220541.jpg" alt="微信图片_20231114220541"></p><p>后来又回校处理毕业的事，六月就带着毕业证来成为正式员工了，当时我非常开心，给我的感觉就是在这个公司上班很舒服，同事们非常好，公司当时说也要融资，然后怎么样怎么样，似乎一切正往最美好的发展，当时我也遇见了我的女朋友，似乎已经走上了人生巅峰哈哈。</p><p>可是好景不长，八月中旬吧突然通知，后续业绩不好了，可能要进行裁员了，当时给我的感觉就像是突然从梦中醒来……开始提心吊胆了，就这样紧张度过了八月份，后来业务似乎好转，老板说先不裁员了，看业务似乎还不错，然后……业务没有预料的那样好转，国庆后突然一个紧急的会议，要进行裁员了……</p><p>公司很人性，给够补偿，就这样我的第一份正式工作结束了。也结束了我北漂的生涯。</p><p>为了离我女朋友更近一些，选择了南京、杭州、上海这三个地方作为下一份工作的地方。</p><p>然后开始准备简历投简历，不得不说，处在如此一个尴尬点上，找工作是真的难，刚毕业经验不多，又不能以应届生经验找，每天boss投到上限，就三四个要我简历，最后都感觉投遍了……</p><p>在北京投了两周后，为了更方便面试，决定南下。在北京收拾、转租、搬家、奔向上海。</p><p>面试很曲折，当时我都感觉人生如此迷茫，有一家南京的，我从上海跑过去，参加线下面试，然后就人事了解一下信息，说最多给我5k多并说这都是这个薪资，并表示后面还可能有技术面，让我回去等消息吧。我nm当时就想骂人，这起码是在南京呀，真这么不值钱吗，之前在南京实习的薪资都快赶上这个了，而且就只是人事了解信息，还要现场跑一趟，还有她当时高傲的样子……越想越气。</p><p>后面又面了一家外包和我现在这家公司，外包当场就说我不错可以，然后后面也谈薪了，说可以满足我的要求，然后说后面发邮件现在还没发……</p><p>然后就是这家，面试现场面，一个是前端组长一个部门leader，说一次面了不用让我跑两趟了，面试很愉快，当时leader就表示，他这边没问题，就是薪资可能达不到我要求，就看后续怎么样了。后面就hr开始给我谈薪了，跟上一家降薪降了不少，没办法，失业时间越久越焦虑就接受了。</p><p>这次找工作花了一个月，感觉是我最难熬的一段时间，已读不回，每天只能投出去三四份简历，回消息的也就那几个，不是应届生，工作经验又不是太长，真的太难了……</p><p>失业的时候我在想，是不是当时选择就错了，如果留在南京那家公司，或者选择上海那家公司，就没那么多曲折的事了，我甚至一度懊悔，自己的选择让自己走了那么多弯路。</p><p>最后还是想明白了，依然是那句话。</p><p>”如果重来一次的话，以我当时的心智和阅历，还是会做出同样的选择。“</p><p>虽然现在生活还不是那么完美，甚至与之前有所差，但是我又有些庆幸，我现在离我很爱我的女朋友很近，离我很好的朋友们很近，情感上的慰藉足以弥补收入上的差距。</p><p>况且这也只是暂时的，我的人生也刚刚开始。</p><p>生如逆旅单行道，哪有岁月可回头，</p><p>加油。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多次重复请求接口优化方案</title>
    <link href="/Tian-1-2/typblog/2023/10/07/2023107-%E5%A4%9A%E6%AC%A1%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <url>/Tian-1-2/typblog/2023/10/07/2023107-%E5%A4%9A%E6%AC%A1%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="多次重复请求接口优化方案"><a href="#多次重复请求接口优化方案" class="headerlink" title="多次重复请求接口优化方案"></a>多次重复请求接口优化方案</h2><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在项目公共组件封装中遇到了这个问题，原因是在这个公共组件中onMounted()调用了一个接口，如果这个组件在其他地方复用就会调一次方法，刚开始没注意这个问题，直到一个页面多次用到这个组件了，一打开这个页面三四个同样的接口！后端小伙伴坐不住了，优化！优化！</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>一开始想不在onMounted()里调用了，触发事件再调用接口，这样什么时候触发就什么时候调接口获取数据得了，但是很快就pass了，这次出现了一个问题，有延迟，触发事件后，还是需要等待一下，产品那边过不了关。所以最好的方法还是在加载页面的时候就直接把数据加载出来，这怎么处理呢？</p><p>突然想到了之前常见的解决多次请求的案例：<strong>防抖和节流</strong></p><p>茅厕顿开！虽然实际情况不同，但是逻辑有些相似，直接上代码</p><p>额外创建getData.ts文件（这里技术栈采用的vue3+ts），</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = [] <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&lt;string, any&gt;;<br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//用来实现延迟效果</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">ms = <span class="hljs-number">200</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useGetData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 调用接口，获取数据</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getApiData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">api</span>();<br>    data = [result?.<span class="hljs-property">data</span>];<br>  &#125;;<br>  <span class="hljs-comment">//如果判断数据存在直接返回</span><br>  <span class="hljs-keyword">if</span> (data &amp;&amp; data?.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; data &#125;;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (count++) &#123;<br>    <span class="hljs-comment">// 如果有计数说明自己不是第 1 个，就等待</span><br>    <span class="hljs-keyword">while</span> (!data || data?.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 是第 1 个就去请求</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">getApiData</span>();<br>  &#125;<br>  count--;<br>  <span class="hljs-keyword">return</span> &#123; data &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码实现的效果就是当短时间内调用时，只会调用一次接口。</p><p>整体逻辑就是第一次调用时，count为0，count加1，执行else里的内容，就会执行getApiData（）方法，但是加入了await，这样就会等待接口完成后再执行下一步。</p><p>而再第二次调用这个方法时，count已经为1，这个时候if判断成功，进入while进行delay()等待，这个时候其实涉及到事件的循环机制了，微任务执行完毕后才能执行下一个微任务，await getApiData（）就是一个异步操作，await后面的函数执行完毕时，await会产生一个微任务，加入队列，await delay()也是。所以当数据获取成功后，执行delay()然后跳出while循环，然后最后return {data}，其实最终目的都是return {data}。</p><p>后面如何再次获取数据时，这个时候也不用经过再判断count了，直接根据之前已经存在过的数据进行返回。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实总的逻辑还是判断上一次有没有数据，但是加入了接口之后，为了避免请求数据延迟问题，利用事件循环机制的原理进行了一定的处理。</p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3封装知识点（三）依赖注入：provide和inject详细介绍</title>
    <link href="/Tian-1-2/typblog/2023/09/19/2023919-Vue3%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9Aprovide%E5%92%8Cinject%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <url>/Tian-1-2/typblog/2023/09/19/2023919-Vue3%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9Aprovide%E5%92%8Cinject%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue3封装知识点（三）依赖注入：provide和inject详细介绍"><a href="#Vue3封装知识点（三）依赖注入：provide和inject详细介绍" class="headerlink" title="Vue3封装知识点（三）依赖注入：provide和inject详细介绍"></a>Vue3封装知识点（三）依赖注入：provide和inject详细介绍</h2><p>[TOC]</p><h3 id="一、provide和inject是什么"><a href="#一、provide和inject是什么" class="headerlink" title="一、provide和inject是什么"></a>一、provide和inject是什么</h3><p>父组件中提供数据，并在子组件中注入这些数据，从而实现了组件之间的数据传递。简单来说就是父组件向子组件传值的一个方式。</p><h3 id="二、为了解决什么问题"><a href="#二、为了解决什么问题" class="headerlink" title="二、为了解决什么问题"></a>二、为了解决什么问题</h3><p>vue3官网对依赖注入解决的问题这样介绍的：</p><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：</p><p><img src="https://cn.vuejs.org/assets/prop-drilling.11201220.png" alt="Prop 逐级透传的过程图示"></p><p>注意，虽然这里的 <code>&lt;Footer&gt;</code> 组件可能根本不关心这些 props，但为了使 <code>&lt;DeepChild&gt;</code> 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。</p><p><code>provide</code> 和 <code>inject</code> 可以帮助我们解决这一问题。 一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p><p><img src="https://cn.vuejs.org/assets/provide-inject.3e0505e4.png" alt="Provide/inject 模式"></p><p>这可以说就是provide和inject的来源，为了解决<strong>Prop 逐级透传问题</strong>的问题</p><h3 id="三、provide和inject如何使用"><a href="#三、provide和inject如何使用" class="headerlink" title="三、provide和inject如何使用"></a>三、provide和inject如何使用</h3><p>这里部分也采用的官网的介绍，讲的很清楚</p><h4 id="1-provide"><a href="#1-provide" class="headerlink" title="1.provide()"></a>1.provide()</h4><p>提供一个值，可以被后代组件注入。</p><ul><li><p><strong>类型</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-keyword">function</span> provide<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>key<span class="hljs-operator">:</span> InjectionKey<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> string<span class="hljs-punctuation">,</span> value<span class="hljs-operator">:</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span><span class="hljs-operator">:</span> void<br></code></pre></td></tr></table></figure></li><li><p><strong>详细信息</strong></p><p><code>provide()</code> 接受两个参数：第一个参数是要注入的 key，可以是一个字符串或者一个 symbol，第二个参数是要注入的值。</p><p>当使用 TypeScript 时，key 可以是一个被类型断言为 <code>InjectionKey</code> 的 symbol。<code>InjectionKey</code> 是一个 Vue 提供的工具类型，继承自 <code>Symbol</code>，可以用来同步 <code>provide()</code> 和 <code>inject()</code> 之间值的类型。</p><p>与注册生命周期钩子的 API 类似，<code>provide()</code> 必须在组件的 <code>setup()</code> 阶段同步调用。</p></li><li><p><strong>示例</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref, provide &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; fooSymbol &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供静态值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供响应式的值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供时将 Symbol 作为 key</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(fooSymbol, count)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-inject"><a href="#2-inject" class="headerlink" title="2.inject()"></a>2.inject()</h4><p>注入一个由祖先组件或整个应用 (通过 <code>app.provide()</code>) 提供的值。</p><ul><li><p><strong>类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 没有默认值</span><br><span class="hljs-keyword">function</span> inject&lt;T&gt;(<span class="hljs-attr">key</span>: <span class="hljs-title class_">InjectionKey</span>&lt;T&gt; | <span class="hljs-built_in">string</span>): T | <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// 带有默认值</span><br><span class="hljs-keyword">function</span> inject&lt;T&gt;(<span class="hljs-attr">key</span>: <span class="hljs-title class_">InjectionKey</span>&lt;T&gt; | <span class="hljs-built_in">string</span>, <span class="hljs-attr">defaultValue</span>: T): T<br><br><span class="hljs-comment">// 使用工厂函数</span><br><span class="hljs-keyword">function</span> inject&lt;T&gt;(<br>  <span class="hljs-attr">key</span>: <span class="hljs-title class_">InjectionKey</span>&lt;T&gt; | <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">defaultValue</span>: <span class="hljs-function">() =&gt;</span> T,<br>  <span class="hljs-attr">treatDefaultAsFactory</span>: <span class="hljs-literal">true</span><br>): T<br></code></pre></td></tr></table></figure></li><li><p><strong>详细信息</strong></p><p>第一个参数是注入的 key（<strong>这个key就是用来和provide设定的第一个参数进行匹配</strong>）。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，<code>inject()</code> 将返回 <code>undefined</code>，除非提供了一个默认值。</p><p>第二个参数是可选的，即在没有匹配到 key 时使用的默认值。</p><p>第二个参数也可以是一个工厂函数，用来返回某些创建起来比较复杂的值。在这种情况下，你必须将 <code>true</code> 作为第三个参数传入，表明这个函数将作为工厂函数使用，而非值本身。</p><p>与注册生命周期钩子的 API 类似，<code>inject()</code> 必须在组件的 <code>setup()</code> 阶段同步调用。</p><p>当使用 TypeScript 时，key 可以是一个类型为 <code>InjectionKey</code> 的 symbol。<code>InjectionKey</code> 是一个 Vue 提供的工具类型，继承自 <code>Symbol</code>，可以用来同步 <code>provide()</code> 和 <code>inject()</code> 之间值的类型。</p></li><li><p><strong>示例</strong></p><p>假设有一个父组件已经提供了一些值，如前面 <code>provide()</code> 的例子中所示：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; inject &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; fooSymbol &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入不含默认值的静态值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入响应式的值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;count&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 通过 Symbol 类型的 key 注入</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> foo2 = <span class="hljs-title function_">inject</span>(fooSymbol)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入一个值，若为空则使用提供的默认值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;default value&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入一个值，若为空则使用提供的函数类型的默认值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-function">() =&gt;</span> </span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"><span class="language-javascript">)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入一个值，若为空则使用提供的工厂函数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> baz = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;factory&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpensiveObject</span>(), <span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-和响应式数据配合使用"><a href="#3-和响应式数据配合使用" class="headerlink" title="3.和响应式数据配合使用"></a>3.和响应式数据配合使用</h4><p>provide和inject也可以传递响应式数据和方法，但是传递响应式数据的时候，官网做了一个推荐使用</p><p>当提供 &#x2F; 注入响应式的数据时，<strong>建议尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</p><p>如下面这个例子：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 在供给方组件内 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; provide, ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> location = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;North Pole&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateLocation</span>(<span class="hljs-params"></span>) </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  location.value = &#x27;South Pole&#x27;</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml"><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;location&#x27;</span>, </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  location,</span><br><span class="hljs-template-variable">  updateLocation</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">)</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 在注入方组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; inject &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> </span></span><span class="hljs-template-variable">&#123; location, updateLocation &#125;</span><span class="language-xml"><span class="language-javascript"> = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;location&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateLocation&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; location &#125;</span><span class="language-xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="4-使用-Symbol-作注入名"><a href="#4-使用-Symbol-作注入名" class="headerlink" title="4.使用 Symbol 作注入名"></a>4.使用 Symbol 作注入名</h4><p>官网同样对注入名做了推荐，如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。可能平常很少用，这里对symbol做一下简单介绍。</p><p><strong>symbol</strong></p><p>在计算机编程中，Symbol是一种基本数据类型，是在ECMAScript 6 (ES6) 中引入的新特性。它是一种原始数据类型，与数字、字符串、布尔值等类似。</p><p>Symbol是一种唯一且不可变的数据类型，每个Symbol值都是唯一的，不会与其他任何值相等，包括其他Symbol值。这使得Symbol非常适合用作对象属性的标识符，以确保不会发生属性名冲突。</p><p>创建Symbol可以使用全局Symbol函数，例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const mySymbol <span class="hljs-operator">=</span> Symbol()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>也可以传递一个可选的描述字符串作为Symbol的标识，这个描述字符串对于调试和输出Symbol时是可选的，但并不影响Symbol的唯一性，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const mySymbol = <span class="hljs-constructor">Symbol(&#x27;<span class="hljs-params">my</span> <span class="hljs-params">unique</span> <span class="hljs-params">symbol</span>&#x27;)</span>;<br></code></pre></td></tr></table></figure><p><strong>应用到provide和inject中</strong></p><p>通常推荐在一个单独的文件中导出这些注入名 Symbol：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// keys.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectionKey = <span class="hljs-built_in">Symbol</span>()<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// 在供给方组件中</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./keys.js&#x27;</span><br><br>provide(myInjectionKey, &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">  要提供的数据</span><br><span class="hljs-comment">*/</span> &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 注入方组件</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">inject</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./keys.js&#x27;</span><br><br>const injected = <span class="hljs-keyword">inject</span>(myInjectionKey)<br></code></pre></td></tr></table></figure><h3 id="四、实现原理"><a href="#四、实现原理" class="headerlink" title="四、实现原理"></a>四、实现原理</h3><p>翻了不少大佬的文章，发现有些理解不同，有说到利用到原型链的，有说没有用到的，仔细理了一下发现是因为vue2和vue3的组件之间的数据绑定和响应式系统不同导致的结果。</p><p><strong>在vue2中组件实例方法和属性的继承是通过原型链来实现的</strong>，而<code>provide</code> 和 <code>inject</code> 就是基于原型链的属性访问来实现跨组件通信。当一个组件通过 <code>provide</code> 提供数据，它会将这些数据添加到其原型链上，然后子组件通过 <code>inject</code> 可以在原型链上查找并访问这些数据。</p><p><strong>在 Vue 3 中 组件的实例方法和属性的继承不再依赖于原型链</strong>，而是 引入了 Composition API，它采用了一种不同的方式来组织组件的代码和状态。组件的选项被重构为一个配置对象，其中 <code>setup</code> 函数用于定义组件的响应式数据、计算属性、方法等。这些选项不再依赖于原型链，而是直接导出给组件实例。</p><p>这个改进带来了以下好处：</p><ol><li>更稳定的数据提供：在 Vue 3 中，每个组件实例都有自己的私有作用域，不会受到原型链的影响，因此不存在 Vue 2 中的潜在问题。</li><li>更好的类型检查：在 Vue 3 中，TypeScript 或 Flow 等类型检查工具可以更准确地检测到 <code>inject</code> 注入的数据类型。</li></ol><p>因为平常大多数是在Vue3中使用，接下来详细介绍一下在vue3中的原理。</p><h4 id="vue3中的实现原理"><a href="#vue3中的实现原理" class="headerlink" title="vue3中的实现原理"></a>vue3中的实现原理</h4><p><strong><code>provide</code> 的原理</strong>：</p><ul><li><code>provide</code> 是在父组件中使用的选项，用于提供数据给子组件。它实际上是一个函数，它会在父组件实例上创建一个名为 <code>_provided</code> 的对象。</li><li><code>_provided</code> 对象存储了提供给子组件的数据，而且这些数据会在整个组件树中可用，子组件可以通过<code>inject</code>选项来访问这些数据。。</li><li>当父组件提供的数据发生变化时，Vue 3 的响应式系统会追踪这些变化并通知所有依赖这些数据的子组件进行更新。</li></ul><p><strong><code>inject</code> 的原理</strong>：</p><ul><li>子组件通过<code>inject</code>选项声明需要注入的数据，可以是一个数组、一个对象或一个函数。这些声明告诉Vue 3要从父组件的提供数据中获取哪些属性。</li><li>当子组件访问通过<code>inject</code>注入的数据时，Vue 3会在组件树中向上搜索父组件，直到找到包含提供数据的组件或到达根组件。</li><li>一旦找到包含提供数据的组件，Vue 3会从该组件的<code>_provided</code>属性中获取相应的数据。</li><li>如果提供的数据是响应式的，子组件将自动成为这些数据的依赖，当提供的数据发生变化时，子组件将被通知并进行更新。</li></ul><h3 id="五、优点和缺点"><a href="#五、优点和缺点" class="headerlink" title="五、优点和缺点"></a>五、优点和缺点</h3><p>该方法可以说很方便解决了父组件给多级子组件传值的问题，但是同时也有一定的局限性，下面分析一下优点和缺点</p><p><strong>优点：</strong></p><ol><li><strong>解耦合（Decoupling）：</strong> <code>provide</code> 和 <code>inject</code> 有助于降低组件之间的耦合度。组件不需要直接了解其依赖项的实现细节，而是通过注入来访问这些依赖，这使得组件更加独立和可复用。</li><li><strong>可测试性（Testability）：</strong> 依赖注入使得单元测试更加容易。你可以轻松地注入模拟对象或测试替身，以测试组件的行为，而不需要实际的外部依赖。</li><li><strong>可维护性（Maintainability）：</strong> 通过将依赖项提取到外部并通过 <code>provide</code> 注入，代码变得更清晰和易于维护。这对于大型应用程序来说特别有价值。</li><li><strong>可扩展性（Scalability）：</strong> <code>provide</code> 和 <code>inject</code> 可以用于共享全局配置、服务或状态管理等全局性的依赖项，使得应用程序更容易扩展和维护。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>复杂性（Complexity）：</strong> 对于小型应用来说，使用 <code>provide</code> 和 <code>inject</code> 可能会增加一些不必要的复杂性。这些特性最有价值的地方通常在大型和复杂的应用程序中。</li><li><strong>容易滥用（Overuse）：</strong> 有时开发人员可能会滥用 <code>provide</code> 和 <code>inject</code>，将所有东西都注入到组件中，导致不必要的复杂性和混乱。需要谨慎权衡。</li><li><strong>不适用于所有场景（Not Suitable for All Scenarios）：</strong> <code>provide</code> 和 <code>inject</code> 更适合用于共享全局配置和服务等情况，对于局部的、仅在某个组件内部使用的依赖项，使用 props 更合适。</li></ol><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>总的来说，<code>provide</code> 和 <code>inject</code> 是一种强大的依赖注入机制，特别适用于大型和复杂的应用程序，以提高代码的可维护性、可测试性和可扩展性。但在小型应用中，可能会增加一些复杂性，需要谨慎使用。在使用时，需要根据具体的场景和需求来判断是否使用这些特性，在组件封装过程中，也可以根据情况进行使用。</p><p><strong>往期更新</strong></p><p><a href="https://blog.csdn.net/qq_49907632/article/details/132476332?spm=1001.2014.3001.5502">vue3封装知识点（一）组件之前传值</a></p><p><a href="https://blog.csdn.net/qq_49907632/article/details/132835976?spm=1001.2014.3001.5502">vue3封装知识点（二）v-model的应用</a></p><p><strong>参考资料</strong></p><p><a href="https://cn.vuejs.org/api/composition-api-dependency-injection.html">vue官网</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3封装知识点（二）v-model的应用</title>
    <link href="/Tian-1-2/typblog/2023/09/12/2023912-Vue3%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89v-model%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/Tian-1-2/typblog/2023/09/12/2023912-Vue3%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89v-model%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue3封装知识点（二）v-model的应用"><a href="#Vue3封装知识点（二）v-model的应用" class="headerlink" title="Vue3封装知识点（二）v-model的应用"></a>Vue3封装知识点（二）v-model的应用</h2><p>[TOC]</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在封装组件中，有一种情况，比如封装一个输入框，需要实时同步输入框内容，这个时候就是需要加入v-model操作了</p><h4 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h4><p>在Vue中，<code>v-model</code> 是一个指令，用于实现双向数据绑定。它通常用于表单元素，例如输入框、复选框和单选按钮，以便将表单输入与Vue组件的数据属性进行绑定。<code>v-model</code> 的原理可以简要概括为以下几个步骤：</p><ol><li><strong>建立绑定</strong>：当你使用 <code>v-model</code> 指令时，Vue会在内部创建一个双向绑定。它将元素的值与指定的数据属性绑定在一起，这意味着任何一方的变化都会影响另一方。</li><li><strong>监听输入事件</strong>：Vue会为绑定的表单元素添加一个监听器，以侦听用户的输入事件（如输入文本或选择选项）。这样，当用户在表单元素上输入内容时，Vue会捕获到这些事件。</li><li><strong>更新数据</strong>：当用户输入内容时，Vue会根据输入事件更新指定的数据属性的值。这意味着用户的输入会自动反映到你的Vue组件的数据上。</li><li><strong>反向更新表单元素的值</strong>：同时，如果在Vue组件的数据属性上发生了变化，Vue会将新的值反向更新到绑定的表单元素上。这会导致表单元素显示最新的数据状态。</li></ol><p><strong>其实也就可以总结其过程:</strong></p><p>绑定值→传给子组件→子组件改变值触发事件→改变绑定值,传递给父组件</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>接下来用来封装element plus组件库中的input框做一下简单实现</p><p>1.首先在父组件中加上v-model绑定上对应的值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;getChild&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/views/components/Child.vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> getChild = <span class="hljs-title function_">ref</span>();</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p>2.在子组件接收v-model传值，并监听数据变化进行渲染数据，然后若触发事件后，利用事件进行更新回传</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Please input&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;change&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, toRefs, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> input = <span class="hljs-title function_">ref</span>();</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> &#123; modelValue &#125; = <span class="hljs-title function_">toRefs</span>(props);</span><br><span class="language-javascript">input.<span class="hljs-property">value</span> = modelValue.<span class="hljs-property">value</span>;</span><br><span class="language-javascript"><span class="hljs-comment">// 监听数据变化进行渲染</span></span><br><span class="language-javascript"><span class="hljs-title function_">watch</span>(</span><br><span class="language-javascript">  <span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">modelValue</span>,</span><br><span class="language-javascript">  <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">    input.<span class="hljs-property">value</span> = newValue;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;update:modelValue&quot;</span>]);</span><br><span class="language-javascript"><span class="hljs-comment">// 触发事件进行回传</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">change</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">emits</span>(<span class="hljs-string">&quot;update:modelValue&quot;</span>, input.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>这里需要注意几个知识点：</p><p><strong>modelValue</strong>：<code>modelValue</code> 是一个内置的 prop 名称，当你在一个自定义组件上使用 <code>v-model</code> 指令时，Vue 3 会默认将 <code>v-model</code> 绑定的值传递给组件的 <code>modelValue</code> prop</p><p><strong>update:modelValue</strong>：<code>update:modelValue</code>事件用于通知父组件要更新与<code>v-model</code>关联的数据属性的值，代码中用<code>emits</code>函数触发<code>update:modelValue</code>事件时，而后面传递的参数将成为新的<code>v-model</code>绑定的值</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里只是在日常封装中想用v-model的一个简单实现，大逻辑是这样做，但在真实需求中需要视情况进行改变，后续如果对封装有进一步了解，会进一步补充。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在element plus中想要多选框（Checkbox）的功能，但是想要单选框(Radio)的圆形样式如何实现</title>
    <link href="/Tian-1-2/typblog/2023/09/07/202397-%E5%9C%A8element-plus%E4%B8%AD%E6%83%B3%E8%A6%81%E5%A4%9A%E9%80%89%E6%A1%86%EF%BC%88Checkbox%EF%BC%89%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E6%83%B3%E8%A6%81%E5%8D%95%E9%80%89%E6%A1%86(Radio)%E7%9A%84%E5%9C%86%E5%BD%A2%E6%A0%B7%E5%BC%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/Tian-1-2/typblog/2023/09/07/202397-%E5%9C%A8element-plus%E4%B8%AD%E6%83%B3%E8%A6%81%E5%A4%9A%E9%80%89%E6%A1%86%EF%BC%88Checkbox%EF%BC%89%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E6%83%B3%E8%A6%81%E5%8D%95%E9%80%89%E6%A1%86(Radio)%E7%9A%84%E5%9C%86%E5%BD%A2%E6%A0%B7%E5%BC%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="在element-plus中想要多选框（Checkbox）的功能，但是想要单选框-Radio-的圆形样式如何实现"><a href="#在element-plus中想要多选框（Checkbox）的功能，但是想要单选框-Radio-的圆形样式如何实现" class="headerlink" title="在element plus中想要多选框（Checkbox）的功能，但是想要单选框(Radio)的圆形样式如何实现"></a>在element plus中想要多选框（Checkbox）的功能，但是想要单选框(Radio)的圆形样式如何实现</h2><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在完成一个业务需求时，需要一个框进行选择或者取消</p><p>element plus中的多选框（Checkbox）可以满足这个需求</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230907110747941.png" alt="image-20230907110747941"></p><p>但是不行，设计稿是根据单选框(Radio)样式出的，下面这个样子</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230907110912275.png" alt="image-20230907110912275"></p><p>可是这个单选框又不能点击取消选择，还是不满足</p><p>想直接改功能，但感觉有点麻烦，所以直接上样式，将多选框方形样式改成圆形！</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>首先检查组件样式</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230907111405771.png" alt="image-20230907111405771"></p><p>发现该元素由el-checkbox__inner控制</p><p>先将其改成圆形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">:deep .el-checkbox__inner &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注</strong>：这里的：deep为深度作用选择器，因为我在项目中使用了 <code>scoped</code> 的缘故</p><p>然后检查发现中间的对号是after伪元素</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230907112238638.png" alt="image-20230907112238638"></p><p>这里就很简单了，只要改变after将对号换成圆圈就可以了</p><p>加入下面这段样式即可实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">:deep .el-checkbox__inner::after &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>) <span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--el-color-white);<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.15s</span> ease-in;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>这里可能不会如何画出来，教大家一个偷懒小方法</p><p>检查radio的样式，找到其样式的after，复制粘贴</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230907112928277.png" alt="image-20230907112928277"></p><p>可能还有点不一样，改一下border-radius为50%，完成！</p>]]></content>
    
    
    <categories>
      
      <category>Element plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Element plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习（一）基本配置</title>
    <link href="/Tian-1-2/typblog/2023/09/01/202391-webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <url>/Tian-1-2/typblog/2023/09/01/202391-webpack%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack学习（一）基本配置"><a href="#webpack学习（一）基本配置" class="headerlink" title="webpack学习（一）基本配置"></a>webpack学习（一）基本配置</h2><p>[TOC]</p><h4 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h4><p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示内容。</p><p>而在深入了解webpack之前，需要先对webpack的配置有一定认识</p><h4 id="五大核心配置"><a href="#五大核心配置" class="headerlink" title="五大核心配置"></a>五大核心配置</h4><h5 id="1-入口（entry"><a href="#1-入口（entry" class="headerlink" title="1.入口（entry)"></a>1.入口（entry)</h5><p>简单来说就是指示 Webpack 从哪个文件开始打包</p><p>详细来说是指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>默认值是 <code>./src/index.js</code>，但你可以通过在webpack.config中配置 <code>entry</code> 属性，来指定一个（或多个）不同的入口起点。例如：</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// 相对路径和绝对路径都行</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-输入（output）"><a href="#2-输入（output）" class="headerlink" title="2.输入（output）"></a>2.输入（output）</h5><p>此部分用来指示 Webpack 打包完的文件输出到哪里去，如何命名等</p><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p><p><strong>例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 入口</span><br>  <span class="hljs-comment">// 相对路径和绝对路径都行</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">// path: 文件输出目录，必须是绝对路径</span><br>    <span class="hljs-comment">// path.resolve()方法返回一个绝对路径</span><br>    <span class="hljs-comment">// __dirname 当前文件的文件夹绝对路径</span><br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <br>      <span class="hljs-comment">// filename: 输出文件名</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;my-first-webpack.bundle.js&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-加载器（loader）"><a href="#3-加载器（loader）" class="headerlink" title="3.加载器（loader）"></a>3.加载器（loader）</h5><p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。但其他资源需要借助 loader，Webpack 才能解析。</p><p>loader的作用就是 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p><p>在更高层面，在 webpack 的配置中，<strong>loader</strong> 有两个属性：</p><ol><li><code>test</code> 属性，识别出哪些文件会被转换。</li><li><code>use</code> 属性，定义出在进行转换时，应该使用哪个 loader。</li></ol><p><strong>例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;my-first-webpack.bundle.js&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-comment">//加载器loader</span><br>  <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-comment">//使用正则表达式匹配文件时，不能添加引号</span><br>    <span class="hljs-attr">rules</span>: [&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;raw-loader&#x27;</span> &#125;],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这相当于给webpack 编译器(compiler) 传递信息</p><p>在编译器打包过程中，碰到「在 <code>require()</code>&#x2F;<code>import</code> 语句中被解析为 ‘.txt’ 的路径」时，在对它打包之前，先 <strong>use(使用)</strong> <code>raw-loader</code> 转换一下</p><h5 id="4-插件（plugins）"><a href="#4-插件（plugins）" class="headerlink" title="4.插件（plugins）"></a>4.插件（plugins）</h5><p>简单来说是用来扩展 Webpack 的功能，loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p><p>所以也可以这样说：插件目的在于解决 loader无法实现的<strong>其他事</strong></p><p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p><p><strong>例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>); <span class="hljs-comment">// 用于访问内置插件</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;raw-loader&#x27;</span> &#125;],<br>  &#125;,<br>    <span class="hljs-comment">//html-webpack-plugin 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。</span><br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> &#125;)],<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="5-模式（model）"><a href="#5-模式（model）" class="headerlink" title="5.模式（model）"></a>5.模式（model）</h5><p>这部分是用来配置当前的模式是出于开发模式还是生产模式，因为开发环境和打包后要上线的环境不一样，要求也不一样，这个时候就需要根据实际需求来对两个模式进行分别配置</p><ul><li>开发模式：development</li><li>生产模式：production</li></ul><p><strong>例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,<span class="hljs-comment">//生成模式</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="总体配置模版"><a href="#总体配置模版" class="headerlink" title="总体配置模版"></a>总体配置模版</h5><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// Node.js的核心模块，专门用来处理文件路径</span><br>const <span class="hljs-attr">path</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;path&quot;</span>)<span class="hljs-punctuation">;</span><br><br>module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// 入口</span><br><span class="hljs-symbol">  entry:</span> <span class="hljs-string">&quot;./src/main.js&quot;</span>,<br>  <span class="hljs-comment">// 输出</span><br><span class="hljs-symbol">  output:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    path:</span> path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br><span class="hljs-symbol">    filename:</span> <span class="hljs-string">&quot;main.js&quot;</span>,<br>  <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-comment">// 加载器</span><br><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    rules:</span> [],<br>  <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-comment">// 插件</span><br><span class="hljs-symbol">  plugins:</span> [],<br>  <span class="hljs-comment">// 模式</span><br><span class="hljs-symbol">  mode:</span> <span class="hljs-string">&quot;development&quot;</span>, <br><span class="hljs-punctuation">&#125;;</span><br><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这部分只是对webpack配置做了个简单介绍，后续会更新各个模块的详细应用，以及常用的一些优化方案，或者了解更深一点的运行机制等等，欢迎关注！</p><p><strong>参考</strong></p><p><a href="https://www.webpackjs.com/">webpack官网</a></p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回流（重排）和重绘—性能优化</title>
    <link href="/Tian-1-2/typblog/2023/08/29/2023829-%E5%9B%9E%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/Tian-1-2/typblog/2023/08/29/2023829-%E5%9B%9E%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="回流（重排）和重绘—性能优化"><a href="#回流（重排）和重绘—性能优化" class="headerlink" title="回流（重排）和重绘—性能优化"></a><strong>回流（重排）和重绘—性能优化</strong></h2><p>[TOC]</p><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h4><p>最近学习React，虚拟dom涉及这一点，而之前的工作中也曾涉及过，回流（重排）和重绘对于项目性能优化这一部分是必不可少的，这里对其做一下总结</p><h4 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a><strong>浏览器渲染过程</strong></h4><p>想要了解其是什么，需要简单了解一下浏览器的形成过程</p><p>浏览器在渲染页面的时候，大致是以下几个步骤：</p><ol><li>解析html生成DOM树，解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成渲染树；</li><li>根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 回流</li><li>根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 重绘</li><li>最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面</li></ol><h4 id="回流（重排）"><a href="#回流（重排）" class="headerlink" title="回流（重排）"></a><strong>回流（重排）</strong></h4><p><strong>回流：</strong>英文叫reflow，指的是当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置，有的将这一过程也称为重排。</p><h5 id="容易造成回流的操作："><a href="#容易造成回流的操作：" class="headerlink" title="容易造成回流的操作："></a><strong>容易造成回流的操作：</strong></h5><p><strong>1、布局流相关操作</strong></p><ul><li>盒模型的相关操作会触发重新布局</li><li>定位相关操作会触发重新布局</li><li>浮动相关操作会触发重新布局</li></ul><p><strong>2、改变节点内的内容</strong><br>改变节点的结构或其中的文本结构会触发重新布局</p><p><strong>3、部分css</strong></p><ul><li>width</li><li>height</li><li>padding</li><li>border</li><li>margin</li><li>position</li><li>top</li><li>left</li><li>bottom</li><li>right</li><li>float</li><li>clear</li><li>text-align</li><li>vertical-align</li><li>line-height</li><li>font-weight</li><li>font-size</li><li>font-family</li><li>overflow</li><li>white-space</li></ul><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a><strong>重绘</strong></h4><p><strong>重绘：</strong>英文叫repaint，当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程，就叫重绘。比如：改变元素的背景颜色、字体颜色等操作会造成重绘。</p><p>回流的过程在重绘的过程前面，所以回流一定会重绘，但重绘不一定会引起回流。</p><p><strong>容易造成重绘操作的css：</strong></p><ul><li>color</li><li>border-style</li><li>border-radius</li><li>text-decoration</li><li>box-shadow</li><li>outline</li><li>background</li></ul><p>每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：</p><ul><li>offsetTop</li><li>offsetLeft</li><li>offsetWidth</li><li>offsetHeight</li><li>scrollTop</li><li>scrollLeft</li><li>scrollWidth</li><li>scrollHeight</li><li>clientTop</li><li>clientLeft</li><li>clientWidth</li><li>clientHeight</li><li>getComputedStyle()</li></ul><p>这些属性或方法都需要得到最新的布局信息，所以浏览器必须去回流执行。因此，在项目中，尽量避免使用上述属性或方法，如果非要使用的时候，也尽量将值缓存起来，而不是一直获取。</p><h4 id="减少回流和重绘"><a href="#减少回流和重绘" class="headerlink" title="减少回流和重绘"></a><strong>减少回流和重绘</strong></h4><p>知道了定义，在日常开发中要尽量避免这些操作，但有时必要的要进行一些操作，如何处理呢，下面是一些优化方案</p><h5 id="合并样式修改"><a href="#合并样式修改" class="headerlink" title="合并样式修改"></a><strong>合并样式修改</strong></h5><p>减少造成回流的次数，如果要给一个节点操作多个css属性，而每一个都会造成回流的话，尽量将多次操作合并成一个，例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>);<br>oDiv.<span class="hljs-property">style</span>.<span class="hljs-property">padding</span> = <span class="hljs-string">&#x27;5px&#x27;</span>;<br>oDiv.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;1px solid #000&#x27;</span>;<br>oDiv.<span class="hljs-property">style</span>.<span class="hljs-property">margin</span> = <span class="hljs-string">&#x27;5px&#x27;</span>;<br></code></pre></td></tr></table></figure><p>操作div的3个css属性，分别是padding、border、margin，此时就可以考虑将多次操作合并为一次。</p><p>方法一：使用style的cssText：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">oDiv.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&#x27;padding:5px; border:1px solid #000; margin:5px;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>方法二：将这几个样式定义给一个类名，然后给标签添加类名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.pbm</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>:<span class="hljs-number">5px</span>; </span><br><span class="language-css">        <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>; </span><br><span class="language-css">        <span class="hljs-attribute">margin</span>:<span class="hljs-number">5px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> oDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>);</span><br><span class="language-javascript">    oDiv.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;pbm&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量操作DOM"><a href="#批量操作DOM" class="headerlink" title="批量操作DOM"></a><strong>批量操作DOM</strong></h5><p>当对DOM有多次操作的时候，需要使用一些特殊处理减少触发回流，其实就是对DOM的多次操作，在脱离标准流后，对元素进行的多次操作，不会触发回流，等操作完成后，再将元素放回标准流。</p><p><strong>脱离标准流的操作有以下3中：</strong></p><ol><li>隐藏元素</li><li>使用文档碎片</li><li>拷贝节点</li></ol><p>例：下面对DOM节点的多次操作，每次都会触发回流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [<br>    &#123;<br>        <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;商品1&quot;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">id</span>:<span class="hljs-number">2</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;商品1&quot;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">id</span>:<span class="hljs-number">3</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;商品1&quot;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">id</span>:<span class="hljs-number">4</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;商品1&quot;</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 假设后面还有很多</span><br>];<br><span class="hljs-keyword">var</span> oUl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);<br>    oLi.<span class="hljs-property">innerText</span> = data[i].<span class="hljs-property">name</span>;<br>    oUl.<span class="hljs-title function_">appendChild</span>(oLi);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样每次给ul中新增一个li的操作，每次都会触发回流。</p><p>方法一：隐藏ul后，给ul添加节点，添加完成后再将ul显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">oUl.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);<br>    oLi.<span class="hljs-property">innerText</span> = data[i].<span class="hljs-property">name</span>;<br>    oUl.<span class="hljs-title function_">appendChild</span>(oLi);<br>&#125;<br>oUl.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;block&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时，在隐藏ul和显示ul的时候，触发了两次回流，给ul添加每个li的时候没有触发回流。</p><p>方法二：创建文档碎片，将所有li先放在文档碎片中，等都放进去以后，再将文档碎片放在ul中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);<br>    oLi.<span class="hljs-property">innerText</span> = data[i].<span class="hljs-property">name</span>;<br>    fragment.<span class="hljs-title function_">appendChild</span>(oLi);<br>&#125;<br>oUl.<span class="hljs-title function_">appendChild</span>(fragment);<br></code></pre></td></tr></table></figure><p>方法三：将ul拷贝一份，将所有li放在拷贝中，等都放进去以后，使用拷贝替换掉ul</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> newUL = oUl.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">var</span> oLi = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);<br>    oLi.<span class="hljs-property">innerText</span> = data[i].<span class="hljs-property">name</span>;<br>    newUL.<span class="hljs-title function_">appendChild</span>(oLi);<br>&#125;<br>oUl.<span class="hljs-property">parentElement</span>.<span class="hljs-title function_">replaceChild</span>(newUl, oUl);<br></code></pre></td></tr></table></figure><h5 id="避免多次触发布局"><a href="#避免多次触发布局" class="headerlink" title="避免多次触发布局"></a><strong>避免多次触发布局</strong></h5><p>如下回到顶部的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">goBack.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> t = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;<br>        t += <span class="hljs-number">10</span>;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> = t;<br>    &#125;,<span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>每隔20毫秒都会重新获取滚动过的距离，每次都会触发回流，代码优化如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">goBack.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> t = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        t += <span class="hljs-number">10</span>;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> = t;<br>    &#125;,<span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>只获取一次，每次都让数字递增，避免每次都获取滚动过的距离。</p><p>对于页面中比较复杂的动画，尽量将元素设置为绝对定位，操作元素的定位属性，这样只有这一个元素会回流，如果不是定位的话，容易引起其父元素以及子元素的回流。</p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3封装知识点（一）组件之间的传值</title>
    <link href="/Tian-1-2/typblog/2023/08/24/2023824-Vue3%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/"/>
    <url>/Tian-1-2/typblog/2023/08/24/2023824-Vue3%E5%B0%81%E8%A3%85%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue3封装技巧（一）组件之间的传值"><a href="#Vue3封装技巧（一）组件之间的传值" class="headerlink" title="Vue3封装技巧（一）组件之间的传值"></a>Vue3封装技巧（一）组件之间的传值</h2><p>用了很久一段时间Vue3+Ts了，工作中对一些常用的组件也进行了一些封装，这里对封装的一些方法进行一些简单的总结。</p><h5 id="1-props传递"><a href="#1-props传递" class="headerlink" title="1.props传递"></a>1.props传递</h5><p>首先在主组件进行定义传值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">这里是主组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">common</span> <span class="hljs-attr">:first</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">common</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> common <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./common.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123;ref&#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> first=<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;传入通用组件的值&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>代码中common是定义的要封装的组件，这里first即是要传入的值</p><p>然后子组件要进行接收传来的值，如下</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">这里是通用组件</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">props.first</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> props=<span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">first</span>:<span class="hljs-title class_">String</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里与vue2不同的是需要利用defineProps进行参数的接收，我这里用到了TS，所以也加入了类型声明。</p><h5 id="2-监听参数变化"><a href="#2-监听参数变化" class="headerlink" title="2.监听参数变化"></a>2.监听参数变化</h5><p>在一些业务中，父组件传给子组件的数据有时候是动态的，这个时候就需要对参数的改变进行识别了</p><p>这里就用到watch了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">watch(<br>  props,<br>  <span class="hljs-function"><span class="hljs-params">(newVal)</span> =&gt;</span> &#123;<br>    console.log(props,<span class="hljs-string">&#x27;props改变了&#x27;</span>);<br>  &#125;,<br>  &#123;<br>    immediate: <span class="hljs-literal">true</span>,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>对props进行监听，如果进行改变，然后怎么进行操作，可以更细节的处理了。</p><p>这里watch的使用可以参考官网<a href="https://cn.vuejs.org/api/reactivity-core.html#watch">https://cn.vuejs.org/api/reactivity-core.html#watch</a></p><h5 id="3-触发事件"><a href="#3-触发事件" class="headerlink" title="3.触发事件"></a>3.触发事件</h5><p>子向父亲传递信息，或者使用父亲的方法应该怎么做呢，这是就是用到emits了</p><p>首先父组件对子组件绑定方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>这里是主组件<br><span class="hljs-tag">&lt;<span class="hljs-name">common</span> <span class="hljs-attr">:first</span>=<span class="hljs-string">&quot;first&quot;</span> @<span class="hljs-attr">getValue</span>=<span class="hljs-string">&quot;getValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">common</span>&gt;</span> //这里的@就是绑定的方法<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> common <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./common.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> first=<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;传入通用组件的值&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getValue</span>=(<span class="hljs-params">val:string</span>)=&gt;&#123; <span class="hljs-comment">//注意这里的参数即是子组件想要传的值</span></span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>绑定后需要在子组件进行接收</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">这里是通用组件</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">props.first</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> props=<span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">first</span>:<span class="hljs-title class_">String</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> emits=<span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;getValue&#x27;</span>])<span class="hljs-comment">//这里进行定义接收</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">watch</span>(</span></span><br><span class="language-javascript"><span class="language-xml">  props,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props,<span class="hljs-string">&#x27;props改变了&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">emits</span>(<span class="hljs-string">&#x27;getValue&#x27;</span>,<span class="hljs-string">&#x27;我触发了&#x27;</span>) <span class="hljs-comment">//想要触发时进行调用</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里在子组件定义接收后，再触发时用emits（’方法名’，传递参数）的形式进行触发，而这个传递参数是你在父组件绑定方法中所定义的参数。</p><h5 id="4-调用子组件方法"><a href="#4-调用子组件方法" class="headerlink" title="4.调用子组件方法"></a>4.调用子组件方法</h5><p>在封装中，也会遇到一些调用子组件的方法，我现在常用的是下面这种</p><p>先用defineExpose将方法进行暴露</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">out</span>=(<span class="hljs-keyword">val</span>:string)=&gt;&#123;<br>console.log(<span class="hljs-string">&#x27;我是子组件的方法&#x27;</span>,<span class="hljs-keyword">val</span>);<br>&#125;<br>defineExpose(&#123;<br><span class="hljs-keyword">out</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后在父组件使用ref绑定子组件，获取其方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>这里是主组件<br><span class="hljs-tag">&lt;<span class="hljs-name">common</span> <span class="hljs-attr">:first</span>=<span class="hljs-string">&quot;first&quot;</span> @<span class="hljs-attr">getValue</span>=<span class="hljs-string">&quot;getValue&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Common&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">common</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> common <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./common.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref,onMounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> first=<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;传入通用组件的值&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getValue</span>=(<span class="hljs-params">val:string</span>)=&gt;&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Common</span>=<span class="hljs-title function_">ref</span>() <span class="hljs-comment">//这里ref名称与上面绑定的ref要保持一致</span></span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript"><span class="hljs-title class_">Common</span>.<span class="hljs-property">value</span>.<span class="hljs-title function_">out</span>(<span class="hljs-string">&#x27;传给你&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// 结果为 ‘我是子组件的方法 传给你’</span></span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里就是先用ref绑定，然后利用其调用方法，括号内的参数即在子组件定义参数。</p><h5 id="5-插槽"><a href="#5-插槽" class="headerlink" title="5.插槽"></a>5.插槽</h5><p>插槽方法可以见我以前总结的内容，这里不再详细讲解 </p><p><a href="https://blog.csdn.net/qq_49907632/article/details/127575530?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_49907632/article/details/127575530?spm=1001.2014.3001.5502</a></p><h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h5><p>上述内容其实就是对常用的组件传值进行的一个总结，真实内容封装其实还是要看组件的具体需求，但是都可能是对这些传值进行的一个应用，后续如果对封装有进一步了解，会进一步补充，敬请期待。。。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite初了解--常用配置总结</title>
    <link href="/Tian-1-2/typblog/2023/08/22/2023822-Vite%E5%88%9D%E4%BA%86%E8%A7%A3--%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/Tian-1-2/typblog/2023/08/22/2023822-Vite%E5%88%9D%E4%BA%86%E8%A7%A3--%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Vite初了解–常用配置总结"><a href="#Vite初了解–常用配置总结" class="headerlink" title="Vite初了解–常用配置总结"></a>Vite初了解–常用配置总结</h2><p>初次学习Vite，配置信息看不懂，慢慢进行了解，这里先对其配置信息进行一个简单的了解</p><p>（默认的配置项，如果不想进行改动，可以不用写，真实项目中可能就只需要写几项配置信息即可）</p><ul><li><code>mode</code>：指定应用程序的模式，可以是开发模式（’development’）或生产模式（’production’）。在开发模式下，Vite 会启用一些调试工具和优化，而在生产模式下，会进行代码压缩和优化。</li><li><code>resolve</code>：用于配置模块解析行为的选项。可以指定别名（alias）来简化导入路径，指定扩展名（extensions）来处理不同类型的模块，还可以配置模块的查找顺序（mainFields）等。（配置别名，为了简化导入路径，一般用的也较多）</li><li><code>root</code>：指定项目的根目录，默认为当前工作目录。</li><li><code>base</code>：指定在构建生产版本时，HTML 文件所在的基础路径。默认情况下，它是一个相对路径（’.&#x2F;‘），可以根据实际需求进行更改。</li><li><code>publicDir</code>：指定公共资源文件夹的路径，默认为 ‘public’。在构建过程中，该文件夹中的内容将被复制到输出目录。</li><li><code>build</code>：构建相关的配置选项。<ul><li><code>target</code>：指定构建的目标浏览器环境，默认为 ‘modules’，表示构建为支持原生 ES 模块的浏览器。可以设置为 ‘esnext’ 或 ‘browserslist’，以根据项目需求选择构建目标。</li><li><code>outDir</code>：指定构建输出目录，默认为 ‘dist’。</li><li><code>assetsDir</code>：指定静态资源的输出目录，默认为 ‘assets’。在构建过程中，这些资源将被复制到输出目录。</li><li><code>sourcemap</code>：控制是否生成源映射文件，默认为 true。</li><li><code>rollupOptions</code>：通过该选项可以自定义 Rollup 打包的配置。可以配置 Rollup 的插件、模块解析方式、代码拆分等。（一般在此会进行代码打包优化）</li></ul></li><li><code>plugins</code>：配置插件。Vite 使用插件系统来扩展其功能。可以通过该选项引入各种插件，如编译 TypeScript、处理 CSS、压缩代码等（该部分一般在项目中使用较多，多数会配置一些插件）</li><li><code>server</code>：开发服务器相关的配置选项。<ul><li><code>host</code>：指定服务器绑定的主机名，默认为 ‘localhost’。</li><li><code>port</code>：指定服务器监听的端口，默认为 3000。</li><li><code>proxy</code>：配置代理服务器，用于解决开发过程中的跨域问题。</li><li><code>open</code>：控制是否在启动开发服务器时自动打开浏览器，默认为 true。</li></ul></li></ul><p>更多配置信息，可以到官网文档中进一步了解 <a href="https://cn.vitejs.dev/config/">https://cn.vitejs.dev/config/</a></p>]]></content>
    
    
    <categories>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在VUE3+Element plus中的el-table实现单元格内超出内容提示功能</title>
    <link href="/Tian-1-2/typblog/2023/06/21/2023621-%E5%9C%A8VUE3+Element-plus%E4%B8%AD%E7%9A%84el-table%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E8%B6%85%E5%87%BA%E5%86%85%E5%AE%B9%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/"/>
    <url>/Tian-1-2/typblog/2023/06/21/2023621-%E5%9C%A8VUE3+Element-plus%E4%B8%AD%E7%9A%84el-table%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E8%B6%85%E5%87%BA%E5%86%85%E5%AE%B9%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="在VUE3-Element-plus中的el-table实现单元格内超出内容提示功能"><a href="#在VUE3-Element-plus中的el-table实现单元格内超出内容提示功能" class="headerlink" title="在VUE3+Element plus中的el-table实现单元格内超出内容提示功能"></a>在VUE3+Element plus中的el-table实现单元格内超出内容提示功能</h2><p>在完成公司业务的时候，表格内容太多会撑开，不太美观，需要做一些优化，发现有一些部分还是需要探讨一下。</p><h4 id="1-Table-column-自带属性"><a href="#1-Table-column-自带属性" class="headerlink" title="1.Table-column 自带属性"></a>1.Table-column 自带属性</h4><p>在Table-column 属性中有个属性</p><table><thead><tr><th>show-overflow-tooltip</th><th>当内容过长被隐藏时显示 tooltip</th></tr></thead></table><p>貌似可以直接实现该功能，但有两个缺点</p><p>（1）隐藏后只能一行显示，想多行省略加入样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">display</span>: -webkit-box;<br>-webkit-line-clamp: <span class="hljs-number">9</span>;<br>-webkit-box-orient: vertical;<br></code></pre></td></tr></table></figure><p>之后提示会不生效了，因为自带属性的提示是根据宽度来进行判断了，而该样式是根据高度进行判断</p><p>（2）表格内容不能嵌套，否则同样样式不会生效，有格式要求非常不方便</p><h4 id="2-利用el-tooltip组件"><a href="#2-利用el-tooltip组件" class="headerlink" title="2.利用el-tooltip组件"></a>2.利用el-tooltip组件</h4><p>直接上代码</p><p>html部分</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;el-tooltip<br>         placement=<span class="hljs-string">&quot;top-start&quot;</span><br>         effect=<span class="hljs-string">&quot;light&quot;</span><br>         :disabled=<span class="hljs-string">&quot;latestTooltipFlag&quot;</span><br>         enterable<br>       &gt;<br>         &lt;template <span class="hljs-comment">#content&gt;</span><br>           &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;last_commoner-tip&quot;</span>&gt;<br>            &lt;<span class="hljs-comment">--提示内容--&gt;</span><br>           &lt;/<span class="hljs-keyword">div</span>&gt;<br>         &lt;/template&gt;<br>         &lt;<span class="hljs-keyword">div</span><br>           <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;last_commoner&quot;</span><br>           <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;latest_apm_visit&quot;</span><br>           @mouseenter=<span class="hljs-string">&quot;latestChange(latest_apm_visit[scope.$index])&quot;</span><br>         &gt;<br>          &lt;<span class="hljs-comment">--展示内容--&gt;</span><br>         &lt;/<span class="hljs-keyword">div</span>&gt;<br>       &lt;/el-tooltip&gt;<br></code></pre></td></tr></table></figure><p>js部分</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> latest_apm_visit = <span class="hljs-keyword">ref</span>();<br><span class="hljs-keyword">const</span> latestChange = (<span class="hljs-keyword">event</span>: any) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.clientHeight &lt; <span class="hljs-keyword">event</span>.scrollHeight) &#123;<br>    latestTooltipFlag.<span class="hljs-keyword">value</span> = <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    latestTooltipFlag.<span class="hljs-keyword">value</span> = <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>css部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.last_commoner-tip</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">380px</span>;<br>&#125;<br><span class="hljs-selector-class">.last_commoner</span> &#123;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-line-clamp: <span class="hljs-number">9</span>; //改变数字显示几行<br>  -webkit-box-orient: vertical;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原理：</strong>通过css设置后，可以判断出元素的clientHeight与scrollHeight是不同的值，通过判断他们的大小，来判断提示是否进行提示，而表格内容会同时出现多个元素所以这里加入了ref，并且通过scope.$index知道是第几个元素，然后通过mouseenter事件进行传值实现，该功能就完成了，可以随意改变显示行数，只需改变-webkit-line-clamp属性即可。</p><p>其实看似方便同样也有缺点，每设置一列都需要加上上面一串代码，想要进行封装但是由于ref的存在，封装难度加大，各位大佬如果有好的封装方法欢迎解答。</p><p>由于感觉不是最优解法，于是打算尝试换种优化，不再超出内容展示了，而是点击展示所有内容，由省略到展示全部。实现并不难，这里不再赘述了，如果各位大佬有更好的方法，欢迎交流。</p>]]></content>
    
    
    <categories>
      
      <category>Element plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Element plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3中的ref与reactive区别</title>
    <link href="/Tian-1-2/typblog/2023/04/06/2023406-Vue3%E4%B8%AD%E7%9A%84ref%E4%B8%8Ereactive%E5%8C%BA%E5%88%AB/"/>
    <url>/Tian-1-2/typblog/2023/04/06/2023406-Vue3%E4%B8%AD%E7%9A%84ref%E4%B8%8Ereactive%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>刚学vue3的时候，每次用ref取值赋值都要用到“.value”后缀，认为非常麻烦，于是乎直接一直用reactive，可是工作后发现项目中几乎都用ref，这时就有点纳闷，为什么呢，来和我一起了解了解吧。</p><h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在 Vue3 中我们可以使用 <code>reactive()</code> 创建一个响应式对象或数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br></code></pre></td></tr></table></figure><p>这个响应式对象其实就是一个 <code>Proxy</code>， Vue 会在这个 <code>Proxy</code> 的属性被访问时收集副作用，属性被修改时触发副作用。</p><p>要在组件模板中使用响应式状态，需要在 <code>setup()</code> 函数中定义并返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      state</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，也可以使用 <code>&lt;script setup&gt;</code> ，<code>&lt;script setup&gt;</code> 中顶层的导入和变量声明可以在模板中直接使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="响应式代理-vs-原始对象"><a href="#响应式代理-vs-原始对象" class="headerlink" title="响应式代理 vs 原始对象"></a>响应式代理 vs 原始对象</h3><p><code>reactive()</code> 返回的是一个原始对象的 <code>Proxy</code>，他们是不相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> raw = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(raw)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy === raw) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>原始对象在模板中也是可以使用的，但修改原始对象不会触发更新。因此，要使用 Vue 的响应式系统，就必须使用代理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> state = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>  state.<span class="hljs-property">count</span>++<br>&#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;&#123; state.count &#125;&#125; <span class="hljs-comment">&lt;!-- 当点击button时，始终显示为 0 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>为保证访问代理的一致性，对同一个原始对象调用 <code>reactive()</code> 会总是返回同样的代理对象，而对一个已存在的代理对象调用 <code>reactive()</code> 会返回其本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> raw = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy1 = <span class="hljs-title function_">reactive</span>(raw)<br><span class="hljs-keyword">const</span> proxy2 = <span class="hljs-title function_">reactive</span>(raw)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy1 === proxy2) <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reactive</span>(proxy1) === proxy1) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> raw = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">nested</span>: raw &#125;)<br><span class="hljs-keyword">const</span> nested = <span class="hljs-title function_">reactive</span>(raw)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">nested</span> === nested) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive()"></a>shallowReactive()</h3><p>在 Vue 中，状态默认都是深层响应式的。但某些场景下，我们可能想创建一个 <code>浅层响应式对象</code> ，让它仅在顶层具有响应性，这时候可以使用 <code>shallowReactive()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReactive</span>(&#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">nested</span>: &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 状态自身的属性是响应式的</span><br>state.<span class="hljs-property">foo</span>++<br><br><span class="hljs-comment">// 下层嵌套对象不是响应式的，不会按期望工作</span><br>state.<span class="hljs-property">nested</span>.<span class="hljs-property">bar</span>++<br></code></pre></td></tr></table></figure><p>注意：浅层响应式对象应该只用于组件中的根级状态。避免将其嵌套在深层次的响应式对象中，因为其内部的属性具有不一致的响应行为，嵌套之后将很难理解和调试。</p><h3 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive() 的局限性"></a>reactive() 的局限性</h3><p>reactive() 虽然强大，但也有以下几条限制：</p><ol><li><p>仅对对象类型有效（对象、数组和 <code>Map</code>、<code>Set</code> 这样的集合类型），而对 <code>string</code>、<code>number</code> 和 <code>boolean</code> 这样的原始类型无效。</p></li><li><p>因为 Vue 的响应式系统是通过属性访问进行追踪的，如果我们直接“替换”一个响应式对象，这会导致对初始引用的响应性连接丢失：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// 非响应式替换</span></span><br><span class="language-javascript">  state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span><br>    &#123;&#123; state &#125;&#125; <span class="hljs-comment">&lt;!-- 当点击button时，始终显示为 &#123; &quot;count&quot;: 0 &#125; --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>将响应式对象的属性赋值或解构至本地变量，或是将该属性传入一个函数时，会失去响应性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><br><span class="hljs-comment">// n 是一个局部变量，和 state.count 失去响应性连接</span><br><span class="hljs-keyword">let</span> n = state.<span class="hljs-property">count</span><br><span class="hljs-comment">// 不会影响 state</span><br>n++<br><br><span class="hljs-comment">// count 也和 state.count 失去了响应性连接</span><br><span class="hljs-keyword">let</span> &#123; count &#125; = state<br><span class="hljs-comment">// 不会影响 state</span><br>count++<br><br><span class="hljs-comment">// 参数 count 同样和 state.count 失去了响应性连接</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callSomeFunction</span>(<span class="hljs-params">count</span>) &#123;<br>  <span class="hljs-comment">// 不会影响 state</span><br>  count++<br>&#125;<br><span class="hljs-title function_">callSomeFunction</span>(state.<span class="hljs-property">count</span>)<br></code></pre></td></tr></table></figure></li></ol><p>为了解决以上几个限制，<code>ref</code> 闪耀登场了！</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h2><p>Vue 提供了一个 <code>ref()</code> 方法来允许我们创建使用任何值类型的响应式 ref 。</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>ref()</code> 将传入的参数包装为一个带有 <code>value</code> 属性的 ref 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count) <span class="hljs-comment">// &#123; value: 0 &#125;</span><br><br>count.<span class="hljs-property">value</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>和响应式对象的属性类似，ref 的 <code>value</code> 属性也是响应式的。同时，当值为对象类型时，Vue 会自动使用 <code>reactive()</code> 处理这个值。</p><p>一个包含对象的 ref 可以响应式地替换整个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">ref</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 这是响应式替换</span><br>  state.<span class="hljs-property">value</span> = <span class="hljs-title function_">ref</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;)<br>&#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;&#123; state &#125;&#125; <span class="hljs-comment">&lt;!-- 当点击button时，显示为 &#123; &quot;count&quot;: 1 &#125; --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>ref 从一般对象上解构属性或将属性传递给函数时，不会丢失响应性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">// 解构之后，和 state.count 依然保持响应性连接</span><br><span class="hljs-keyword">const</span> &#123; count &#125; = state<br><span class="hljs-comment">// 会影响 state</span><br>count.<span class="hljs-property">value</span>++<br><br><span class="hljs-comment">// 该函数接收一个 ref, 和传入的值保持响应性连接</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callSomeFunction</span>(<span class="hljs-params">count</span>) &#123;<br>  <span class="hljs-comment">// 会影响 state</span><br>  count.<span class="hljs-property">value</span>++<br>&#125;<br><span class="hljs-title function_">callSomeFunction</span>(state.<span class="hljs-property">count</span>)<br></code></pre></td></tr></table></figure><p><code>ref()</code> 让我们能创建使用任何值类型的 ref 对象，并能够在不丢失响应性的前提下传递这些对象。这个功能非常重要，经常用于将逻辑提取到 <code>组合式函数</code> 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// mouse.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMouse</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> &#123; x, y &#125;<br>&#125;<br>js复制代码&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useMouse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mouse.js&#x27;</span><br><span class="hljs-comment">// 可以解构而不会失去响应性</span><br><span class="hljs-keyword">const</span> &#123; x, y &#125; = <span class="hljs-title function_">useMouse</span>()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="ref-的解包"><a href="#ref-的解包" class="headerlink" title="ref 的解包"></a>ref 的解包</h3><p>所谓解包就是获取到 ref 对象上 <code>value</code> 属性的值。常用的两种方法就是 <code>.value</code> 和 <code>unref()</code>。 <code>unref()</code> 是 Vue 提供的方法，如果参数是 ref ，则返回 value 属性的值，否则返回参数本身。</p><h4 id="ref-在模板中的解包"><a href="#ref-在模板中的解包" class="headerlink" title="ref 在模板中的解包"></a>ref 在模板中的解包</h4><p>当 ref 在模板中作为顶层属性被访问时，它们会被自动解包，不需要使用  <code>.value</code> 。下面是之前的例子，使用 <code>ref()</code> 代替：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123; count &#125;&#125; <span class="hljs-comment">&lt;!-- 无需 .value --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还有一种情况，如果文本插值（<code>&#123;&#123; &#125;&#125;</code>）计算的最终值是 <code>ref</code> ，也会被自动解包。下面的非顶层属性会被正确渲染出来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> object = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>) &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123; object.foo &#125;&#125; <span class="hljs-comment">&lt;!-- 无需 .value --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其他情况则不会被自动解包，如：object.foo 不是顶层属性，文本插值（<code>&#123;&#123; &#125;&#125;</code>）计算的最终值也不是 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-keyword">const</span> object = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>) &#125;<br></code></pre></td></tr></table></figure><p>下面的内容将不会像预期的那样工作：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码&lt;<span class="hljs-selector-tag">div</span>&gt;&#123;&#123; <span class="hljs-selector-tag">object</span><span class="hljs-selector-class">.foo</span> + <span class="hljs-number">1</span> &#125;&#125;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>渲染的结果会是 <code>[object Object]1</code>，因为 <code>object.foo</code> 是一个 ref 对象。我们可以通过将 <code>foo</code> 改成顶层属性来解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> object = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>) &#125;<br><span class="hljs-keyword">const</span> &#123; foo &#125; = object<br>css<br>复制代码&lt;div&gt;&#123;&#123; foo + <span class="hljs-number">1</span> &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>现在结果就可以正确地渲染出来了。</p><h4 id="ref-在响应式对象中的解包"><a href="#ref-在响应式对象中的解包" class="headerlink" title="ref 在响应式对象中的解包"></a>ref 在响应式对象中的解包</h4><p>当一个 <code>ref</code> 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; count &#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>) <span class="hljs-comment">// 0</span><br><br>state.<span class="hljs-property">count</span> = <span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>只有当嵌套在一个深层响应式对象内时，才会发生解包。当 ref 作为 <code>浅层响应式对象</code> 的属性被访问时则不会解包：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码const count = <span class="hljs-built_in">ref</span>(<span class="hljs-number">0</span>)<br>const state = <span class="hljs-built_in">shallowReactive</span>(&#123; count &#125;)<br><br>console<span class="hljs-selector-class">.log</span>(state.count) <span class="hljs-comment">// &#123; value: 0 &#125; 而不是 0</span><br></code></pre></td></tr></table></figure><p>如果将一个新的 ref 赋值给一个已经关联 ref 的属性，那么它会替换掉旧的 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; count &#125;)<br><br><span class="hljs-keyword">const</span> otherCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>)<br>state.<span class="hljs-property">count</span> = otherCount<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 此时 count 已经和 state.count 失去连接</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="ref-在数组和集合类型的解包"><a href="#ref-在数组和集合类型的解包" class="headerlink" title="ref 在数组和集合类型的解包"></a>ref 在数组和集合类型的解包</h4><p>跟响应式对象不同，当 ref 作为响应式数组或像 <code>Map</code> 这种原生集合类型的元素被访问时，不会进行解包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> books = <span class="hljs-title function_">reactive</span>([<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue 3 Guide&#x27;</span>)])<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(books[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>)<br><br><span class="hljs-keyword">const</span> map = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)]]))<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;count&#x27;</span>).<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef()"></a>toRef()</h3><p><code>toRef</code> 是基于响应式对象上的一个属性，创建一个对应的 ref 的方法。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> fooRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><br><span class="hljs-comment">// 更改源属性会更新该 ref</span><br>state.<span class="hljs-property">foo</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooRef.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 更改该 ref 也会更新源属性</span><br>fooRef.<span class="hljs-property">value</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><code>toRef()</code> 在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; toRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(<span class="hljs-comment">/* ... */</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 将 `props.foo` 转换为 ref，然后传入一个组合式函数</span></span><br><span class="language-javascript"><span class="hljs-title function_">useSomeFeature</span>(<span class="hljs-title function_">toRef</span>(props, <span class="hljs-string">&#x27;foo&#x27;</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>toRef</code> 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。如果将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可以考虑使用带有 <code>get</code> 和 <code>set</code> 的 <code>computed</code> 替代。</p><p>注意：即使源属性当前不存在，<code>toRef()</code> 也会返回一个可用的 ref。这让它在处理可选 props 的时候非常有用，相比之下 <code>toRefs</code> 就不会为可选 props 创建对应的 refs 。下面我们就来了解一下 <code>toRefs</code> 。</p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h3><p><code>toRefs()</code> 是将一个响应式对象上的所有属性都转为 ref ，然后再将这些 ref 组合为一个普通对象的方法。这个普通对象的每个属性和源对象的属性保持同步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>&#125;)<br><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-comment">// const stateAsRefs = &#123;</span><br><span class="hljs-comment">//   foo: toRef(state, &#x27;foo&#x27;),</span><br><span class="hljs-comment">//   bar: toRef(state, &#x27;bar&#x27;)</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> stateAsRefs = <span class="hljs-title function_">toRefs</span>(state)<br><br>state.<span class="hljs-property">foo</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stateAsRefs.<span class="hljs-property">foo</span>.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><br><br>stateAsRefs.<span class="hljs-property">foo</span>.<span class="hljs-property">value</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>从组合式函数中返回响应式对象时，<code>toRefs</code> 相当有用。它可以使我们解构返回的对象时，不失去响应性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// feature.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFeature</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>  &#125;)<br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 返回时将属性都转为 ref</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">toRefs</span>(state)<br>&#125;<br>xml复制代码&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useFeature &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./feature.js&#x27;</span><br><span class="hljs-comment">// 可以解构而不会失去响应性</span><br><span class="hljs-keyword">const</span> &#123; foo, bar &#125; = <span class="hljs-title function_">useFeature</span>()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>toRefs</code> 只会为源对象上已存在的属性创建 ref。如果要为还不存在的属性创建 ref，就要用到上面提到的 <code>toRef</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>reactive仅对对象类型有效（对象、数组和 <code>Map</code>、<code>Set</code> 这样的集合类型）</strong>，而对 <code>string</code>、<code>number</code> 和 <code>boolean</code> 这样的原始类型无效。因为 Vue 的响应式系统是通过属性访问进行追踪的，<strong>如果我们直接“替换”一个响应式对象，这会导致对初始引用的响应性连接丢失。</strong></p><p><strong>ref对类型没有限制</strong>，其中的value和响应式对象的属性类似，ref 的 <code>value</code> 属性也是响应式的。同时，当值为对象类型时，Vue 会自动使用 <code>reactive()</code> 处理这个值，<strong>一个包含对象的 ref 可以响应式地替换整个对象</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决git pull时出现冲突无法pull时的问题</title>
    <link href="/Tian-1-2/typblog/2023/03/13/2023313-%E8%A7%A3%E5%86%B3git-pull%E6%97%B6%E5%87%BA%E7%8E%B0%E5%86%B2%E7%AA%81%E6%97%A0%E6%B3%95pull%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/Tian-1-2/typblog/2023/03/13/2023313-%E8%A7%A3%E5%86%B3git-pull%E6%97%B6%E5%87%BA%E7%8E%B0%E5%86%B2%E7%AA%81%E6%97%A0%E6%B3%95pull%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="解决git-pull时出现冲突无法pull时的问题"><a href="#解决git-pull时出现冲突无法pull时的问题" class="headerlink" title="解决git pull时出现冲突无法pull时的问题"></a>解决git pull时出现冲突无法pull时的问题</h2><p>我们在开发的时候正常pull是可以pull下来的，但当其他人和你的代码在同一个文件进行修改时，就会出现冲突，如下面场景：</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230313130242853.png" alt="image-20230313130242853"></p><p>这个可以看到它其实是给了两种解决方法</p><blockquote><p>Please commit your changes or stash them before you merge.</p></blockquote><p>但是直接commit时，它会进入一个编辑状态，这个时候其实相当于已经进行合并了，但这会出现一些问题，有一些冲突可能报错。</p><p>所以我也是经过尝试后采用了第二种方法</p><h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>先对这些命令进行简单的介绍</p><p><strong>git stash</strong>: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br><strong>git stash pop</strong>: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br><strong>git stash list</strong>: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br><strong>git stash clear</strong>: 清空Git栈。</p><p>根据这些命令，再遇见pull冲突时可以进行以下的流程</p><ol><li>git stash </li><li>git pull</li><li>git add .</li><li>git stash pop</li></ol><p>在进行这四步后，如果有冲突，我们就能在我们的编辑器中看到了，如下：</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230313131500260.png" alt="image-20230313131500260"></p><p>解决完冲突后，就直接进行add、commit、push三件套即可</p><p>用stash的操作的原理就相当于，先利用没有修改过的代码进行代码拉取，然后再将备份的代码与已经拉取的代码在本地合并，然后进行本地的冲突修改。这样就避免了直接commit合并代码造成的问题了。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>popover弹窗框中的teleported属性--Element plus踩坑日记</title>
    <link href="/Tian-1-2/typblog/2023/02/13/2023213-popover%E5%BC%B9%E7%AA%97%E6%A1%86%E4%B8%AD%E7%9A%84teleported%E5%B1%9E%E6%80%A7--Element-plus%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    <url>/Tian-1-2/typblog/2023/02/13/2023213-popover%E5%BC%B9%E7%AA%97%E6%A1%86%E4%B8%AD%E7%9A%84teleported%E5%B1%9E%E6%80%A7--Element-plus%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="popover弹窗框中的teleported属性–Element-plus踩坑日记"><a href="#popover弹窗框中的teleported属性–Element-plus踩坑日记" class="headerlink" title="popover弹窗框中的teleported属性–Element plus踩坑日记"></a>popover弹窗框中的teleported属性–Element plus踩坑日记</h2><p>今天在做项目时，有一个地方用到了弹窗框，但是有需求需要修改弹窗的阴影部分</p><p>比如下方的</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230213185801885.png" alt="image-20230213185801885"></p><p>我想对阴影进行修改，但是很是纳闷，各种标签选择器都不生效，很奇怪。</p><p>按照以往对element plus样式修改是完全没问题的。</p><p>带着疑问问了带我实习的师傅，发现了这个属性</p><p><strong>teleported</strong>：是否将 popover 的下拉列表插入至 body 元素默认值为true</p><p>把这个属性改为false，成功了！！！ 但是为什么呢</p><p>将 popover 的下拉列表插入至 body 元素不应该也生效吗？？</p><p>经过查看HTML结构，我发现了问题</p><p>这个插入body元素确实是插入了body元素中，但是它是仅是降了一级成为了<strong>body的children</strong></p><p>它和我们组件的内容成为兄弟关系了！</p><p>如下图</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230213190747921.png" alt="image-20230213190747921"></p><p>可知，弹窗框是在组件内容之外了，所以在组件内操作的样式没有对弹窗框生效</p><p>而改为false之后就成为下面的效果了</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20230213191109825.png" alt="image-20230213191109825"></p><p>而样式也成功生效</p>]]></content>
    
    
    <categories>
      
      <category>Element plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Element plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将数组里所有字符串转换为数字快捷方法</title>
    <link href="/Tian-1-2/typblog/2023/01/10/2023110-%E5%B0%86%E6%95%B0%E7%BB%84%E9%87%8C%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E5%BF%AB%E6%8D%B7%E6%96%B9%E6%B3%95/"/>
    <url>/Tian-1-2/typblog/2023/01/10/2023110-%E5%B0%86%E6%95%B0%E7%BB%84%E9%87%8C%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E5%BF%AB%E6%8D%B7%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="将数组里所有字符串转换为数字快捷方法"><a href="#将数组里所有字符串转换为数字快捷方法" class="headerlink" title="将数组里所有字符串转换为数字快捷方法"></a>将数组里所有字符串转换为数字快捷方法</h2><p><strong>使用 map()可以快速解决</strong></p><p><strong>字符串 &#x3D;&gt; 数字：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const value= [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br>value = value.<span class="hljs-built_in">map</span>(<span class="hljs-built_in">Number</span>) <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>这里扩展一下</p><p><strong>数字&#x3D;&gt;字符串 ：</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> value= [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>value = value.map(<span class="hljs-built_in">String</span>) // [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪元素中用来选择相同元素中的某个元素的实际应用</title>
    <link href="/Tian-1-2/typblog/2022/12/19/20221219-%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E7%94%A8%E6%9D%A5%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <url>/Tian-1-2/typblog/2022/12/19/20221219-%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E7%94%A8%E6%9D%A5%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="伪元素中用来选择相同元素中的某个元素的实际应用"><a href="#伪元素中用来选择相同元素中的某个元素的实际应用" class="headerlink" title="伪元素中用来选择相同元素中的某个元素的实际应用"></a>伪元素中用来选择相同元素中的某个元素的实际应用</h2><h5 id="first-child-选择器"><a href="#first-child-选择器" class="headerlink" title=":first-child 选择器"></a>:first-child 选择器</h5><p>选择属于其父元素的首个子元素的每个元素，并为其设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child<br><br>&#123;<br><br><span class="hljs-attribute">background-color</span>:yellow;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>例子1 选择列表中的第一个元素并设置其样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child<br><br>&#123;<br><br><span class="hljs-attribute">background</span>:yellow;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>例子2 设置每个的首个子元素，并设置其样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&gt;<span class="hljs-selector-pseudo">:first</span>-child<br><br>&#123;<br><br><span class="hljs-attribute">background</span>:yellow;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="last-child-选择器"><a href="#last-child-选择器" class="headerlink" title=":last-child 选择器"></a>:last-child 选择器</h5><p>:last-child 选择器匹配属于其父元素的最后一个子元素的每个元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:last-child</span><br><br>&#123;<br><br><span class="hljs-attribute">background</span>:<span class="hljs-number">#ff0000</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="nth-child-选择器"><a href="#nth-child-选择器" class="headerlink" title=":nth-child() 选择器"></a>:nth-child() 选择器</h5><p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。</p><p>规定属于其父元素的第二个子元素的每个 p 的背景色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)<br><br>&#123;<br><br><span class="hljs-attribute">background</span>:<span class="hljs-number">#ff0000</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实例1 Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词(第一个子元素的下标是 1)。</p><p>在这里，我们为奇数和偶数 p 元素指定两种不同的背景色：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//奇数</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(odd)<br><br>&#123;<br><br><span class="hljs-attribute">background</span>:<span class="hljs-number">#ff0000</span>;<br><br>&#125;<br><span class="hljs-comment">//整数</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(even)<br><br>&#123;<br><br><span class="hljs-attribute">background</span>:<span class="hljs-number">#0000ff</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实例2 使用公式 (an + b)。描述：表示周期的长度，n 是计数器(从 0 开始)，b 是偏移值。</p><p>在这里，我们指定了下标是 3 的倍数的所有 p 元素的背景色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>n+<span class="hljs-number">0</span>)<br><br>&#123;<br><br><span class="hljs-attribute">background</span>:<span class="hljs-number">#ff0000</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>:nth-of-type(n)与:nth-child()功能类似，</p><p>不同之处在于:nth-of-type(n)是属于父元素的特定类型元素，</p><p>:nth-child()是不指定类型，p,div,span等等都算</p><p>:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素.</p><p><strong>下面再细节总结一下其他情况</strong></p><p>3、nth-child(3)</p><p>表示选择第3个标签，代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;<span class="hljs-attribute">background</span>:<span class="hljs-number">#090</span>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中的3也可以改成其它数字，如4、5等。想选择第几个标签，就填写几。</p><p>4、nth-child(2n)</p><p>这个表示选择列表中的偶数标签，即选择 第2、第4、第6…… 标签。</p><p>5、nth-child(2n-1)</p><p>这个表示选择列表中的奇数标签，即选择 第1、第3、第5、第7……标签。</p><p>6、nth-child(n+3)</p><p>这个表示选择列表中的标签从第3个开始到最后。</p><p>7、nth-child(-n+3)</p><p>这个表示选择列表中的标签从0到3，即小于3的标签。</p><p>8、nth-last-child(3)</p><p>这个表示选择列表中的倒数第3个标签</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode踩坑日记--行尾序列LF和CRLF</title>
    <link href="/Tian-1-2/typblog/2022/12/11/20221211-Vscode%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0--%E8%A1%8C%E5%B0%BE%E5%BA%8F%E5%88%97LF%E5%92%8CCRLF/"/>
    <url>/Tian-1-2/typblog/2022/12/11/20221211-Vscode%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0--%E8%A1%8C%E5%B0%BE%E5%BA%8F%E5%88%97LF%E5%92%8CCRLF/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="Vscode踩坑日记–行尾序列LF和CRLF"><a href="#Vscode踩坑日记–行尾序列LF和CRLF" class="headerlink" title="Vscode踩坑日记–行尾序列LF和CRLF"></a>Vscode踩坑日记–行尾序列LF和CRLF</h2><p>今天一上午什么也没干，一直配置Vscode，之前因为代码提交问题，需要解决配置一下eslint，问题就来了。</p><p>插件，配置信息什么都写好了还是一堆错误？？让我很懵逼</p><p>大概是下面这个样子</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20221211120549415.png" alt="image-20221211120549415"></p><p>一开始就单纯以为是配置Elsint没有生效，于是重新配置，甚至把vscode重新安了一遍，可是错误还消失。</p><p>最后搞了一上午竟然是因为行尾序列!!</p><p>下面这个东西</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20221211120923006.png" alt="image-20221211120923006"></p><p>将CRLF切换成LF解决了??</p><p>我又百度了百度，终于搞清了原因，下面对这种两种换行模式做一下简单介绍吧</p><p><strong>LF和CRLF是什么</strong></p><p>CRLF 是 carriage return line feed 的缩写，中文意思是回车换行。</p><p>LF 是 line feed 的缩写，中文意思也是换行。</p><p>它们都是文本换行的方式。</p><p><strong>区别</strong></p><p>在文本处理中LF, CR&#x2F;LF是不同操作系统上使用的换行符.<br>Dos和windows采用回车+换行CR&#x2F;LF表示下一行,<br>而UNIX&#x2F;Linux采用换行符LF表示下一行，<br>苹果机(MAC OS系统)也采用换行符LF表示下一行。</p><p>所以说到底，还是因为操作系统的区别。</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20221211122021241.png" alt="image-20221211122021241"></p>]]></content>
    
    
    <categories>
      
      <category>各种配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReactHooks常用钩子</title>
    <link href="/Tian-1-2/typblog/2022/11/28/20221128-ReactHooks%E5%B8%B8%E7%94%A8%E9%92%A9%E5%AD%90/"/>
    <url>/Tian-1-2/typblog/2022/11/28/20221128-ReactHooks%E5%B8%B8%E7%94%A8%E9%92%A9%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="ReactHooks常用钩子"><a href="#ReactHooks常用钩子" class="headerlink" title="ReactHooks常用钩子"></a>ReactHooks常用钩子</h2><p>好久没用react了，这里对常用的ReactHooks做一下总结</p><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1.useState"></a>1.useState</h3><p><strong>useState 会返回一个数组</strong>：<strong>一个 state，一个更新 state 的函数</strong></p><ul><li>在初始化渲染期间，返回的状态 (state) 与传入的第一个参数值相同</li><li>你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它<strong>不会把新的 state 和旧的 state 进行合并，而是直接替换</strong></li></ul><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,&#123;useState&#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [first, setfirst] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;second&#x27;</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;first&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;</span><br><span class="language-xml">        setfirst(&quot;three&quot;)</span><br><span class="language-xml">    &#125;&#125;&gt;click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2.useEffect"></a>2.useEffect</h3><p><strong>格式：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">first</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">//清理函数 会在组件卸载时及下一次副作用函数调用之前执行</span><br>        <span class="hljs-built_in">second</span><br>      &#125; <br>    &#125;, [third])<br></code></pre></td></tr></table></figure><p>useEffect 接收一个函数，该函数会在组件渲染到屏幕之后才执行，该函数有要求：<strong>要么返回一个能清除副作用的函数，要么就不返回任何内容</strong>，所以return是可选的</p><p>useEffect 第一个参数 callback, 返回的 second， second作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。</p><p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 second，和执行新的 effect 第一个参数 callback 。</p><p>对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 setTimeout回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。</p><h3 id="3-useCallback"><a href="#3-useCallback" class="headerlink" title="3.useCallback"></a>3.useCallback</h3><p>记忆函数 防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用; 只有第二个参数 变化了，才重新声明一次</p><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const handleAdd=<span class="hljs-built_in">useCallback</span>(<br>        ()=&gt;&#123;<br>            <span class="hljs-built_in">setlist</span>(<span class="hljs-selector-attr">[...list,text]</span>)<br>            <span class="hljs-built_in">settext</span>(<span class="hljs-string">&quot;&quot;</span>)<br>        &#125;,<br>      <span class="hljs-selector-attr">[list,text]</span>,<br>    )<br></code></pre></td></tr></table></figure><p>比如上面的例子，当第二个参数的list,text值发生了变化时，第一个参数就会进行一次更新</p><h3 id="4-useMemo"><a href="#4-useMemo" class="headerlink" title="4.useMemo"></a>4.useMemo</h3><p>useMemo相当于vue中的计算属性 也具有记忆函数功能 </p><p>与useCallback的唯一的区别是：useCallback 不会执行第一个参数函数，而是将它返回给你，</p><p>而 useMemo 会执行第一个函数并且将函数执行结果返回给你</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const cacheSomething = use<span class="hljs-constructor">Memo(<span class="hljs-params">create</span>,<span class="hljs-params">deps</span>)</span><br></code></pre></td></tr></table></figure><h3 id="5-useRef"><a href="#5-useRef" class="headerlink" title="5.useRef"></a>5.useRef</h3><p>React的uesRef这里我认为和vue3的useRef非常相似，下面进行一个简单介绍</p><p>useRef 可以用来获取元素，缓存状态，接受一个状态 initState 作为初始值，返回一个 ref 对象 cur, cur 上有一个 current 属性就是 ref 对象需要获取的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cur = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(initState)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cur.<span class="hljs-property">current</span>)<br></code></pre></td></tr></table></figure><p><strong>useRef 基础用法：</strong></p><p><strong>useRef 获取 DOM 元</strong>素，在 React Native 中虽然没有 DOM 元素，但是也能够获取组件的节点信息（ fiber 信息 ）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoUseRef</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> dom= <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handerSubmit</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>        <span class="hljs-comment">/*  &lt;div &gt;表单组件&lt;/div&gt;  dom 节点 */</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dom.<span class="hljs-property">current</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;/* ref 标记当前dom节点 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;dom&#125;</span> &gt;</span>表单组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>handerSubmit()&#125; &gt;提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上通过 useRef 来获取 DOM 节点。</p><p><strong>useRef 保存状态，</strong> 可以利用 useRef 返回的 ref 对象来保存状态，只要当前组件不被销毁，那么状态就会一直存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> status = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>)<br><span class="hljs-comment">/* 改变状态 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChangeStatus</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  status.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-useContext"><a href="#6-useContext" class="headerlink" title="6.useContext"></a>6.useContext</h3><p>useContext ，来获取父级组件传递过来的 context 值，这个当前值就是最近的父级组件 Provider 设置的 value 值，useContext 参数一般是由 createContext 方式创建的 ,也可以父级上下文 context 传递的 ( 参数为 context )。useContext 可以代替 context.Consumer 来获取 Provider 中保存的 value 值。</p><p>所以我是这样理解的<strong>useContext就是上下文</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useContext</span>(context)<br></code></pre></td></tr></table></figure><p>useContext 接受一个参数，一般都是 context 对象，返回值为 context 对象内部保存的 value 值。</p><p><strong>useContext 基础用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用createContext创建并初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Context</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">/* 用useContext方式 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoContext</span> = (<span class="hljs-params"></span>)=&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>:any = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">Context</span>)<br>    <span class="hljs-comment">/* my name is alien */</span><br><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> my name is &#123; value.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">/* 用Context.Consumer 方式 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoContext1</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Consumer</span>&gt;</span></span><br><span class="language-xml">         &#123;/*  my name is alien  */&#125;</span><br><span class="language-xml">        &#123; (value)=&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> my name is &#123; value.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Consumer</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">name:</span>&#x27;<span class="hljs-attr">alien</span>&#x27; , <span class="hljs-attr">age:18</span> &#125;&#125; &gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">DemoContext</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">DemoContext1</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-useReducer"><a href="#7-useReducer" class="headerlink" title="7.useReducer"></a>7.useReducer</h3><p>useReducer 是 react-hooks 提供的能够在无状态组件中运行的类似redux的功能 api 。</p><p><strong>useReducer 基础介绍：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [ ①state , ②dispatch ] = <span class="hljs-title function_">useReducer</span>(③reducer)<br>复制代码<br></code></pre></td></tr></table></figure><p>① 更新之后的 state 值。</p><p>② 派发更新的 dispatchAction 函数, 本质上和 useState 的 dispatchAction 是一样的。</p><p>③ 一个函数 reducer ，我们可以认为它就是一个 redux 中的 reducer , reducer的参数就是常规reducer里面的state和action, 返回改变后的state, 这里有一个需要注意的点就是：<strong>如果返回的 state 和之前的 state ，内存指向相同，那么组件将不会更新。</strong></p><p><strong>useReducer 基础用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoUseReducer</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-comment">/* number为更新后的state值,  dispatchNumbner 为当前的派发函数 */</span><br>   <span class="hljs-keyword">const</span> [ number , dispatchNumbner ] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function">(<span class="hljs-params">state,action</span>)=&gt;</span>&#123;<br>       <span class="hljs-keyword">const</span> &#123; payload , name  &#125; = action<br>       <span class="hljs-comment">/* return的值为新的state */</span><br>       <span class="hljs-keyword">switch</span>(name)&#123;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;add&#x27;</span>:<br>               <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span><br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sub&#x27;</span>:<br>               <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span> <br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br>             <span class="hljs-keyword">return</span> payload       <br>       &#125;<br>       <span class="hljs-keyword">return</span> state<br>   &#125;,<span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      当前值：&#123; number &#125;</span><br><span class="language-xml">      &#123; /* 派发更新 */ &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>dispatchNumbner(&#123; name:&#x27;add&#x27; &#125;)&#125; &gt;增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>dispatchNumbner(&#123; name:&#x27;sub&#x27; &#125;)&#125; &gt;减少<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>dispatchNumbner(&#123; name:&#x27;reset&#x27; ,payload:666 &#125;)&#125; &gt;赋值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123; /* 把dispatch 和 state 传递给子组件  */ &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyChildren</span>  <span class="hljs-attr">dispatch</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">dispatchNumbner</span> &#125; <span class="hljs-attr">State</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">number</span> &#125;&#125; /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CORS 跨域资源共享—Node.js</title>
    <link href="/Tian-1-2/typblog/2022/11/25/20221125-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E2%80%94Node.js/"/>
    <url>/Tian-1-2/typblog/2022/11/25/20221125-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E2%80%94Node.js/</url>
    
    <content type="html"><![CDATA[<h2 id="CORS-跨域资源共享—Node-js"><a href="#CORS-跨域资源共享—Node-js" class="headerlink" title="CORS 跨域资源共享—Node.js"></a>CORS 跨域资源共享—Node.js</h2><h3 id="cors-中间件解决跨域"><a href="#cors-中间件解决跨域" class="headerlink" title="cors 中间件解决跨域"></a>cors 中间件解决跨域</h3><ul><li>安装中间件：<code>npm install cors</code></li><li>导入中间件：<code>const cors = require(&#39;cors&#39;)</code></li><li>配置中间件：<code>app.use(cors())</code></li></ul><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul><li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h3 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h3><ul><li><code>Access-Control-Allow-Origin</code>：制定了允许访问资源的外域 URL</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://bruceblog.io&#x27;</span>)<br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Headers</code></li><li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</code></li><li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 A<code>ccess-Control-Allow-Headers</code> 对额外的请求头进行声明，否则这次请求会失败！</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type, X-Custom-Header&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>Access-Control-Allow-Methods</code></li><li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code> 来指明实际请求所允许使用的 HTTP 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;POST, GET, DELETE, HEAD&#x27;</span>)<br>res.<span class="hljs-title function_">setHEader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul><li>请求方式：GET、POST、HEAD 三者之一</li><li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application&#x2F;x-www-formurlencoded、multipart&#x2F;form-data、text&#x2F;plain）</li></ul><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><ul><li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了 application&#x2F;json 格式的数据</li></ul><p>在浏览器与服务器正式通信之前，浏览器会先发送 <strong>OPTION</strong> 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node操作mysql</title>
    <link href="/Tian-1-2/typblog/2022/11/25/20221125-Node%E6%93%8D%E4%BD%9Cmysql/"/>
    <url>/Tian-1-2/typblog/2022/11/25/20221125-Node%E6%93%8D%E4%BD%9Cmysql/</url>
    
    <content type="html"><![CDATA[<h2 id="Node操作mysql"><a href="#Node操作mysql" class="headerlink" title="Node操作mysql"></a>Node操作mysql</h2><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><ol><li>安装 mysql 模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install mysql<br></code></pre></td></tr></table></figure><ol><li>建立连接</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><br><span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>  <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>  <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><ol><li>测试是否正常工作</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;select 1&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="操作-mysql-数据库"><a href="#操作-mysql-数据库" class="headerlink" title="操作 mysql 数据库"></a>操作 mysql 数据库</h3><p>1.查询数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;select * from users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>2.插入数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ? 表示占位符</span><br><span class="hljs-keyword">const</span> user=&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;王超&#x27;</span>,<span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;pc1234&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;insert into user (username,password) values(?, ?)&#x27;</span><br><span class="hljs-comment">// 使用数组的形式为占位符指定具体的值</span><br>db.<span class="hljs-title function_">query</span>(sql, [user.<span class="hljs-property">username</span>, user.<span class="hljs-property">password</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入成功&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;55520&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;insert into users set ?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sql, user, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>3.更新数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;update users set username=?, password=? where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sql, [username, password, id], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>快捷方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;Bruce&#x27;</span>,<span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;55520&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;update users set ? where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sql, [user, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>4.删除数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sql = <span class="hljs-string">&#x27;delete from users where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sql, id, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用 delete 语句会真正删除数据，保险起见，使用标记删除的形式，模拟删除的动作。即在表中设置状态字段，标记当前的数据是否被删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sqlDelet=<span class="hljs-string">&#x27;update user set status =? where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlDelet,[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],<span class="hljs-function">(<span class="hljs-params">err, results</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>) <br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化--Node.js</title>
    <link href="/Tian-1-2/typblog/2022/11/19/20221119-%E6%A8%A1%E5%9D%97%E5%8C%96--Node.js/"/>
    <url>/Tian-1-2/typblog/2022/11/19/20221119-%E6%A8%A1%E5%9D%97%E5%8C%96--Node.js/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化—Node-js"><a href="#模块化—Node-js" class="headerlink" title="模块化—Node.js"></a>模块化—Node.js</h1><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul><li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li><li>模块化可提高代码的复用性和可维护性，实现按需加载。</li><li>模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li></ul><h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><ul><li>内置模块</li><li>自定义模块</li><li>第三方模块</li></ul><h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><ul><li>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li><li>防止全局变量污染</li></ul><h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul><li>自定义模块中都有一个 <code>module</code> 对象，存储了和当前模块有关的信息</li><li>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 <code>module.exports</code> 指向的对象。</li><li>默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。最终共享的结果，以 <code>module.exports</code> 指向的对象为准。</li></ul><h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><ul><li>每个模块内部，<code>module</code> 变量代表当前模块</li><li><code>module</code> 变量是一个对象，<code>module.exports</code> 是对外的接口</li><li>加载某个模块即加载该模块的 <code>module.exports</code> 属性</li></ul><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 <code>require()</code> 不会导致模块的代码被执行多次，提高模块加载效率。</p><h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p><h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 <code>./</code> 或 <code>../</code> 开头，否则会作为内置模块或第三方模块加载。</p><p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p><ul><li>按确切的文件名加载</li><li>补全 <code>.js</code> 扩展名加载</li><li>补全 <code>.json</code> 扩展名加载</li><li>补全 <code>.node</code> 扩展名加载</li><li>报错</li></ul><h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul><li>若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</li><li>如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li></ul><p>例如，假设在 <code>C:\Users\bruce\project\foo.js</code> 文件里调用了 <code>require(&#39;tools&#39;)</code>，则 Node.js 会按以下顺序查找：</p><ul><li><code>C:\Users\bruce\project\node_modules\tools</code></li><li><code>C:\Users\bruce\node_modules\tools</code></li><li><code>C:\Users\node_modules\tools</code></li><li><code>C:\node_modules\tools</code></li></ul><h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p><ul><li>在被加载的目录下查找 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口</li><li>如果没有 <code>package.json</code> 文件，或者 <code>main</code> 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js</code> 文件。</li><li>若失败则报错</li></ul>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express—node.js</title>
    <link href="/Tian-1-2/typblog/2022/11/19/20221119-Express%E2%80%94node.js/"/>
    <url>/Tian-1-2/typblog/2022/11/19/20221119-Express%E2%80%94node.js/</url>
    
    <content type="html"><![CDATA[<h1 id="Express—Node-js"><a href="#Express—Node-js" class="headerlink" title="Express—Node.js"></a>Express—Node.js</h1><p><a href="https://www.expressjs.com.cn/">官网传送门(opens new window)</a></p><blockquote><p>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</p></blockquote><p>Express 是用于快速创建服务器的第三方模块。</p><h2 id="Express-初体验"><a href="#Express-初体验" class="headerlink" title="Express 初体验"></a>Express 初体验</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 Express：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install express<br></code></pre></td></tr></table></figure><p>创建服务器，监听客户端请求，并返回内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 web 服务器</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span> &#125;)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过 req.query 可以获取到客户端发送过来的查询参数</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<br>&#125;)<br><br><span class="hljs-comment">// 这里的 :id 是一个动态的参数</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:ids/:username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.params 是动态匹配到的 URL 参数，默认是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li><li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，存放静态文件的目录名不会出现在 URL 中</li><li>访问静态资源时，会根据托管顺序查找文件</li><li>可为静态资源访问路径添加前缀</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/bruce&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;bruce&#x27;</span>))<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">可直接访问 public, files 目录下的静态资源</span><br><span class="hljs-comment">http://localhost:3000/images/bg.jpg</span><br><span class="hljs-comment">http://localhost:3000/css/style.css</span><br><span class="hljs-comment">http://localhost:3000/js/login.js</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span><br><span class="hljs-comment">http://localhost:8080/bruce/images/logo.png</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h2><p>创建路由模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建路由对象</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br><span class="hljs-comment">// 挂载具体路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)<br>&#125;)<br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 向外导出路由对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure><p>注册路由模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 注册路由模块，添加访问前缀</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><ul><li>中间件是指流程的中间处理环节</li><li>服务器收到请求后，可先调用中间件进行预处理</li><li>中间件是一个函数，包含 <code>req, res, next</code> 三个参数，<code>next()</code> 参数把流转关系交给下一个中间件或路由</li></ul><p><strong>中间件的作用：</strong></p><p>多个中间件之间，共享同一份req和res，基于这样的特性，我们可以在上游的中间件中，统一为req或res对象添加自定义属性或方法，供下游的中间件或路由进行使用</p><p><strong>中间件注意事项；</strong></p><ul><li>在注册路由之前注册中间件（错误级别中间件除外）</li><li>中间件可连续调用多个</li><li>别忘记调用 <code>next()</code> 函数</li><li><code>next()</code> 函数后别写代码</li><li>多个中间件共享 <code>req</code>、 <code>res</code>对象</li></ul><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/image-20221119161950670.png" alt="image-20221119161950670"></p><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><ul><li>通过 <code>app.use()</code> 定义的中间件为全局中间件</li><li>这时访问其他接口都会调用该中间件</li><li>定义多个全局中间件时，会按照编写顺序从前往后执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 定义第一个全局中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第1个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><span class="hljs-comment">// 定义第二个全局中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第2个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 定义中间件函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw1</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第一个局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw2</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第二个局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-comment">// 两种定义局部中间件的方式</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/hello&#x27;</span>, mw2, mw1, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello page.&#x27;</span>))<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, [mw1, mw2], <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;about page.&#x27;</span>))<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>))<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h3><p>1.应用级别的中间件</p><ul><li>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 <code>app</code> 实例上的中间件</li></ul><p>2.路由级别的中间件</p><ul><li>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 <code>app</code> 实例上，路由级别中间件绑定到 <code>router</code> 实例上。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span> router)<br></code></pre></td></tr></table></figure><p>3.错误级别的中间件</p><ul><li>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 <code>(err, req, res, next)</code> 。</li><li>错误级别的中间件必须注册在所有路由之后</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;服务器内部发生了错误！&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发生了错误！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Error：&#x27;</span> + err.<span class="hljs-property">message</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>4.Express 内置中间件</p><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><ul><li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>())<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统模块，path 路径模块,http模块—Node.js</title>
    <link href="/Tian-1-2/typblog/2022/11/18/20221118-Node%E5%AD%A6%E4%B9%A0day01%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97%EF%BC%8Cpath-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/"/>
    <url>/Tian-1-2/typblog/2022/11/18/20221118-Node%E5%AD%A6%E4%B9%A0day01%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97%EF%BC%8Cpath-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统模块，path-路径模块-http模块—Node-js"><a href="#文件系统模块，path-路径模块-http模块—Node-js" class="headerlink" title="文件系统模块，path 路径模块,http模块—Node.js"></a>文件系统模块，path 路径模块,http模块—Node.js</h1><h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>语法格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(path[, options], callback)<br></code></pre></td></tr></table></figure><ul><li><p><code>path</code>：文件路径</p></li><li><p>&#96;&#96;&#96;<br>options</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  ：配置选项，若是字符串则指定编码格式<br><br>  - `encoding`：编码格式<br>  - `flag`：打开方式<br><br>- ```<br>  callback<br></code></pre></td></tr></table></figure><p>：回调函数</p><ul><li><code>err</code>：错误信息</li><li><code>data</code>：读取的数据，如果未指定编码格式则返回一个 Buffer</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span>(err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failed!&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;content:&#x27;</span> + data)<br>&#125;)<br><br><br><span class="hljs-comment">// 复制文件内容</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;C:/Users/笔记.mp3&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br><span class="hljs-keyword">if</span>(!err) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><span class="hljs-comment">// 将data写入到文件中</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&quot;C:/Users/hello.jpg&quot;</span>, data, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br><span class="hljs-keyword">if</span>(!err)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件写入成功&quot;</span>);<br>&#125;<br>&#125; );<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>语法格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFile</span>(file, data[, options], callback)<br></code></pre></td></tr></table></figure><ul><li><code>file</code>：文件路径</li><li><code>data</code>：写入内容</li><li><code>options</code>：配置选项，包含 <code>encoding, mode, flag</code>；若是字符串则指定编码格式</li><li><code>callback</code>：回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello Nodejs&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failed!&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success!&#x27;</span>)<br>&#125;)<br><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;C:/Users/hello.txt&#x27;</span>, <span class="hljs-string">&#x27;通过 writeFile 写入的内容&#x27;</span>, &#123; <span class="hljs-attr">flag</span>: <span class="hljs-string">&#x27;w&#x27;</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功！&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题 __dirname"></a>路径动态拼接问题 <code>__dirname</code></h3><ul><li>在使用 fs 模块操作文件时，如果提供的操作路径是以 <code>./</code> 或 <code>../</code> 开头的相对路径时，容易出现路径动态拼接错误的问题</li><li>原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li><li>解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li><li><code>__dirname</code> 获取文件所处的绝对路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><h3 id="路径拼接-path-join"><a href="#路径拼接-path-join" class="headerlink" title="路径拼接 path.join()"></a>路径拼接 <code>path.join()</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 注意 ../ 会抵消前面的路径</span><br><span class="hljs-comment">// ./ 会被忽略</span><br><span class="hljs-keyword">const</span> pathStr = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-string">&#x27;/b/c&#x27;</span>, <span class="hljs-string">&#x27;../../&#x27;</span>, <span class="hljs-string">&#x27;./d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr) <span class="hljs-comment">// \a\d\e</span><br><br>fs.<span class="hljs-title function_">readFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./files/1.txt&#x27;</span>), <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="获取路径中文件名-path-basename"><a href="#获取路径中文件名-path-basename" class="headerlink" title="获取路径中文件名 path.basename()"></a>获取路径中文件名 <code>path.basename()</code></h3><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">basename</span>(path[, ext])<br></code></pre></td></tr></table></figure><ul><li>path: 文件路径</li><li>ext: 文件扩展名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 定义文件的存放路径</span><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><br><span class="hljs-keyword">const</span> fullName = path.<span class="hljs-title function_">basename</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName) <span class="hljs-comment">// index.html</span><br><br><span class="hljs-keyword">const</span> nameWithoutExt = path.<span class="hljs-title function_">basename</span>(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameWithoutExt) <span class="hljs-comment">// index</span><br></code></pre></td></tr></table></figure><h3 id="获取路径中的文件扩展名-path-extname"><a href="#获取路径中的文件扩展名-path-extname" class="headerlink" title="获取路径中的文件扩展名 path.extname()"></a>获取路径中的文件扩展名 <code>path.extname()</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><br><span class="hljs-keyword">const</span> fext = path.<span class="hljs-title function_">extname</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fext) <span class="hljs-comment">// .html</span><br></code></pre></td></tr></table></figure><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。</p><h3 id="创建基本-Web-服务器"><a href="#创建基本-Web-服务器" class="headerlink" title="创建基本 Web 服务器"></a>创建基本 Web 服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br><span class="hljs-comment">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-keyword">const</span> method = req.<span class="hljs-property">method</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">`Your request url is <span class="hljs-subst">$&#123;url&#125;</span>, and request method is <span class="hljs-subst">$&#123;method&#125;</span>`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br><br>  <span class="hljs-comment">// 设置 Content-Type 响应头，解决中文乱码的问题</span><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  <span class="hljs-comment">// 向客户端响应内容</span><br>  res.<span class="hljs-title function_">end</span>(str)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uniapp网络请求封装及使用</title>
    <link href="/Tian-1-2/typblog/2022/11/02/2022112-uniapp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/Tian-1-2/typblog/2022/11/02/2022112-uniapp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="uniapp网络请求封装及使用"><a href="#uniapp网络请求封装及使用" class="headerlink" title="uniapp网络请求封装及使用"></a>uniapp网络请求封装及使用</h3><p>uniapp自带的uni.request()可以直接进行网络请求，但每次用到就重写一次比较麻烦，这里进行一下简单的封装，方便以后接口的调用。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a><strong>第一步</strong></h5><p>首先创建utils&#x2F;requset.js文件，利用promise先对uni.request()做封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">request</span> = (<span class="hljs-params">config</span>) =&gt; &#123;<br><span class="hljs-comment">// 处理 apiUrl</span><br>config.<span class="hljs-property">url</span> = <span class="hljs-string">&#x27;你的链接服务器地址&#x27;</span> + config.<span class="hljs-property">url</span>;<br><span class="hljs-keyword">if</span>(!config.<span class="hljs-property">data</span>)&#123;<br>config.<span class="hljs-property">data</span> = &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>uni.<span class="hljs-title function_">request</span>(config).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> &#123;<br><span class="hljs-comment">// 异常</span><br><span class="hljs-keyword">if</span> (responses[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-title function_">reject</span>(&#123;message : <span class="hljs-string">&quot;网络超时&quot;</span>&#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">let</span> response = responses[<span class="hljs-number">1</span>].<span class="hljs-property">data</span>; <br><span class="hljs-title function_">resolve</span>(response);<br>&#125;<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br><span class="hljs-title function_">reject</span>(error);<br>&#125;)<br>&#125;)<br><span class="hljs-keyword">return</span> promise;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> request;<br><br></code></pre></td></tr></table></figure><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a><strong>第二步</strong></h5><p>为了更进一步减少代码冗余，可以把请求放在一个api.js中写好，使用的时候直接调用方法就可以了</p><p>创建api&#x2F;index.js文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">import request from <span class="hljs-string">&#x27;@/utils/request.js&#x27;</span>; <span class="hljs-regexp">//</span> 引入封装好的request<br><br><span class="hljs-regexp">//</span> 文章列表获取<br>export <span class="hljs-keyword">function</span> getNavlist (data) &#123;<br>return request(&#123;<br>method: <span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-regexp">//</span> 请求方式<br>url: <span class="hljs-string">&#x27;/dataApi/news/navlist.php&#x27;</span>, <span class="hljs-regexp">//</span> 请求的url<br>data: data <span class="hljs-regexp">//</span> 参数<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h5><p>在相应的页面进行引用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">//先引入</span><br><span class="hljs-keyword">import</span> &#123;getNavlist&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/index.js&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//在对应的方法进行调用</span><br><span class="hljs-function"><span class="hljs-title">getNavData</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">getNavlist</span>()<span class="hljs-selector-class">.then</span>(res=&gt;&#123; <span class="hljs-comment">//请求成功</span><br>        console<span class="hljs-selector-class">.log</span>(res)<br>    &#125;)<span class="hljs-selector-class">.catch</span>(res =&gt; &#123; <span class="hljs-comment">//请求失败</span><br><br>&#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>这就是uniapp封装网络请求的主要过程了，其实主要也就一个点，对promise的使用。</p>]]></content>
    
    
    <categories>
      
      <category>uniapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.@click失效？@click.native</title>
    <link href="/Tian-1-2/typblog/2022/11/01/2022111-@click%E5%A4%B1%E6%95%88%EF%BC%9F@click.native/"/>
    <url>/Tian-1-2/typblog/2022/11/01/2022111-@click%E5%A4%B1%E6%95%88%EF%BC%9F@click.native/</url>
    
    <content type="html"><![CDATA[<h2 id="click失效？-click-native"><a href="#click失效？-click-native" class="headerlink" title="@click失效？@click.native"></a>@click失效？@click.native</h2><p> 记录@click绑定事件的一个坑</p><h5 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h5><p> 今天日常开发的时候，封装好了一个组件，但是给组件绑定了@click事件后，事件却没有执行。<br> 主要代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;row&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in newsArr&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">newsbox</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">&quot;item&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;goDetail(item)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">newsbox</span>&gt;</span></span><br>&lt;/div&gt;<br><br><br><span class="hljs-comment">//跳转到详情页</span><br><span class="hljs-title function_">goDetail</span>(<span class="hljs-params">item</span>)&#123;<br>uni.<span class="hljs-title function_">navigateTo</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">`/pages/detail/detail?cid=<span class="hljs-subst">$&#123;item.classid&#125;</span>&amp;id=<span class="hljs-subst">$&#123;item.id&#125;</span>`</span><br>&#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">newsbox是我自己封装的一个组件，问题就出在这儿，newsbox是子组件，想要直接在父组件触发click方法，直接写上@click是不能触发方法的。</p><p>这时候需要在@click.native就可以解决了，可是为什么呢</p><h5 id="官网的解释"><a href="#官网的解释" class="headerlink" title="官网的解释"></a>官网的解释</h5><p>你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native 。</p><h5 id="通俗点讲："><a href="#通俗点讲：" class="headerlink" title="通俗点讲："></a>通俗点讲：</h5><p>就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加’. native’事件是无法触 发的。</p><p>可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。</p><h5 id="更细一点来讲"><a href="#更细一点来讲" class="headerlink" title="更细一点来讲"></a>更细一点来讲</h5><p>是因为使用.native之后父级组件可以像处理原生的DOM事件一样通过 v-on 监听子组件实例的任意事件(@即为v-on:的简写)，如果不加natvie，会认为监听的是来自子组件自定义的事件，然而子组件内也没有使用$emit()来将子组件的触发事件抛出，因此onSubmit()方法没有执行。<br> 所以这里也引出了对绑定@click无效有两种解决方法</p><ol><li>在组件上绑定@click.native&#x3D;”XXX”，</li><li>子组件中添加 this.$emit (“click” ，value) 方法 将子组件的值传到父组件。</li></ol><p>但是这种方法相对麻烦，比如组件中有多个事件，需要重复添加 $emit () 方法。不过具体怎么选还是看自己的需求了。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《突然好想你》--五月天</title>
    <link href="/Tian-1-2/typblog/2022/10/27/20221027-%E3%80%8A%E7%AA%81%E7%84%B6%E5%A5%BD%E6%83%B3%E4%BD%A0%E3%80%8B--%E4%BA%94%E6%9C%88%E5%A4%A9/"/>
    <url>/Tian-1-2/typblog/2022/10/27/20221027-%E3%80%8A%E7%AA%81%E7%84%B6%E5%A5%BD%E6%83%B3%E4%BD%A0%E3%80%8B--%E4%BA%94%E6%9C%88%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="《突然好想你》–五月天"><a href="#《突然好想你》–五月天" class="headerlink" title="《突然好想你》–五月天"></a>《突然好想你》–五月天</h2><p>今天晚上突然不想学习了，想发发牢骚</p><p>突然想起来一首歌《突然好想你》，不是想谈恋爱什么的，而是感觉这首歌真的好自由。</p><p>特别喜欢五月天演唱会的版本，</p><p>人山人海，五月天双手一张开，真的好享受。</p><p>疫情已经是第三个年头了，</p><p>下一次这样的场景不知道是什么时候，</p><p>疫情耽搁的许多事，</p><p>耽搁的大学生活，</p><p>耽搁的旅游，</p><p>……</p><p>如今来到一个地方实习，也算半只脚踏入社会，</p><p>大学已经差不多远去了。</p><p>不想那么多，要不都是遗憾</p><p><strong>听歌！听歌！</strong></p><br><p>我们 那么甜 那么美</p><p>那么相信</p><p>那么疯 那么热烈的曾经</p><p><strong>为何我们 还是要奔向</strong></p><p><strong>各自的幸福和遗憾中老去</strong></p><p><img src="https://img-blog.csdnimg.cn/02cbf336921347e1924ff1d9c4e530cc.png"><br><strong>突然好想你</strong></p><p><strong>你会在哪里</strong></p><p><strong>过得快乐或委屈</strong></p><p><strong>突然好想你</strong></p><p><strong>突然锋利的回忆</strong></p><p><strong>突然模糊的眼睛</strong></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>听歌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Echarts中折线图出现的问题</title>
    <link href="/Tian-1-2/typblog/2022/10/25/20221025-%E8%A7%A3%E5%86%B3Echarts%E4%B8%AD%E6%8A%98%E7%BA%BF%E5%9B%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/Tian-1-2/typblog/2022/10/25/20221025-%E8%A7%A3%E5%86%B3Echarts%E4%B8%AD%E6%8A%98%E7%BA%BF%E5%9B%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、设置y轴最小刻度值"><a href="#一、设置y轴最小刻度值" class="headerlink" title="一、设置y轴最小刻度值"></a>一、设置y轴最小刻度值</h2><p>原本y轴没有设置数据的话会自动生成的，但是在实际工作中遇到了问题</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210251038437.png" alt="image-20221025103830110"></p><p>在线用户不能为小数</p><p>所以最少要设置一个最小刻度</p><p>需要在yAxis中加入minInterval，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">yAxis : [<br>               &#123;<br>                    minInterval:<span class="hljs-number">1</span>,<br>                    type : <span class="hljs-string">&#x27;value&#x27;</span>,<br>                    axisLine:&#123;<br>                           lineStyle:&#123;<br>                               <span class="hljs-attribute">color</span>:<span class="hljs-string">&#x27;#888888&#x27;</span><br>                           &#125;<br>                       &#125;<br>                 &#125;<br>          ],<br></code></pre></td></tr></table></figure><h2 id="二、两个值相同却为曲线"><a href="#二、两个值相同却为曲线" class="headerlink" title="二、两个值相同却为曲线"></a>二、两个值相同却为曲线</h2><p>在测试的时候就出现了这样的问题</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210251042790.png" alt="image-20221025104219770"></p><p>两个值相同，可为什么要弯曲一下</p><p>找了许多资料，只需要加入一个配置项就行了</p><p>在series中加入 smoothMonotone: ‘x’,</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing">series : [<br>                    &#123;<br>                        smoothMonotone: <span class="hljs-string">&#x27;x&#x27;</span>,<br>                        type:<span class="hljs-string">&#x27;line&#x27;</span>,<br>                        barWidth : <span class="hljs-number">20</span>,<br>                        <span class="hljs-built_in">smooth</span>:<span class="hljs-literal">true</span>,<br>                        data:data.<span class="hljs-property">dataY</span>[<span class="hljs-number">0</span>],<br>                        <span class="hljs-comment">//设置柱状图渐变颜色</span><br>                        itemStyle: &#123;<br>                            <span class="hljs-built_in">normal</span>: &#123;<br>                                barBorderRadius:[<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-comment">// 柱状图顶部圆角</span><br>                                <span class="hljs-type">color</span>: <span class="hljs-keyword">new</span> $.<span class="hljs-property">echarts</span>.<span class="hljs-property">graphic</span>.<span class="hljs-property">LinearGradient</span>(<br>                                    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,   <span class="hljs-comment">// 1,0,0,0表示从左向右</span><br>                                    [<br>                                        &#123;offset: <span class="hljs-number">1</span>, <span class="hljs-type">color</span>: <span class="hljs-string">&#x27;#287AF6&#x27;</span>&#125;,  <br>                                        &#123;offset: <span class="hljs-number">0</span>, <span class="hljs-type">color</span>: <span class="hljs-string">&#x27;#287AF6&#x27;</span>&#125;<br>                                    ]<br>                                )<br>                            &#125;<br>                        &#125;<br>                    &#125;,<br>            ]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
      <category>Echarts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Echarts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现Aes加解密</title>
    <link href="/Tian-1-2/typblog/2022/10/24/20221024-%E5%AE%9E%E7%8E%B0Aes%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <url>/Tian-1-2/typblog/2022/10/24/20221024-%E5%AE%9E%E7%8E%B0Aes%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="实现Aes加解密"><a href="#实现Aes加解密" class="headerlink" title="实现Aes加解密"></a>实现Aes加解密</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> CryptoJS <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crypto-js&#x27;</span><br><br>//注意key和iv为<span class="hljs-number">16</span>进制，不能为非<span class="hljs-number">16</span>进制字符<br>const keyHex = CryptoJS.enc.Utf8.parse(&quot;xxxxxxxxxxxxxxxx&quot;);<br>const iv = CryptoJS.enc.Utf8.parse(&quot;xxxxxxxxxxxxxxxx&quot;);<br><br><span class="hljs-keyword">function</span> encode(msg)&#123;<br>    const <span class="hljs-keyword">encrypted</span> = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(msg), keyHex, &#123;<br>        iv: iv,<br>        mode: CryptoJS.mode.CBC,<br>        padding: CryptoJS.pad.Pkcs7<br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">encrypted</span>.toString();<br>&#125;<br><br><span class="hljs-keyword">function</span> decode(enc)&#123;<br>    let decrypt = CryptoJS.AES.decrypt(enc, keyHex, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;);<br>    let decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);<br>    <span class="hljs-keyword">return</span> decryptedStr.toString();<br>&#125;<br><br>export <span class="hljs-keyword">default</span> &#123;<br>    encode,<br>    decode<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插槽</title>
    <link href="/Tian-1-2/typblog/2022/10/19/20221019-%E6%8F%92%E6%A7%BD/"/>
    <url>/Tian-1-2/typblog/2022/10/19/20221019-%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong>父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">父组件中：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br>子组件中：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>               <span class="hljs-comment">&lt;!-- 定义插槽 --&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>插槽默认内容...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml">父组件中：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里 通过slot声明是哪个插槽 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br>子组件中：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>               <span class="hljs-comment">&lt;!-- 定义插槽 --&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>插槽默认内容...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>插槽默认内容...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。简单来说可以定义为：让插槽中的内容能访问子组件中的数据。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">父组件中：</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;scopeData&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 生成的是ul列表 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;g in scopeData.games&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;g&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">g</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scopeData&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 生成的是h4标题 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;g in scopeData.games&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;g&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">g</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span></span><br><span class="language-xml">子组件中：</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:games</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Category&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;title&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//数据在子组件自身</span></span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                        <span class="hljs-attr">games</span>:[<span class="hljs-string">&#x27;红色警戒&#x27;</span>,<span class="hljs-string">&#x27;穿越火线&#x27;</span>,<span class="hljs-string">&#x27;劲舞团&#x27;</span>,<span class="hljs-string">&#x27;超级玛丽&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">                    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><p>这里需要注意一点版本的变化</p><p>v-slot 指令自 Vue 2.6.0 起被引入，提供更好的支持 slot 和 slot-scope attribute 的 API 替代方案。v-slot 完整的由来参见这份 RFC。在接下来所有的 2.x 版本中 slot 和 slot-scope attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。也就是说，在vue2版本中，我们仍可以使用slot跟slot-scope，但是在vue3中就只能使用v-slot了。<br>原来的带有slot的具名插槽</p><p>&#x2F;&#x2F;B.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>写法变化，使用v-slot</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">B</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是header部分<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是main（默认插槽）部分<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是footer部分<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">B</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>原来的作用域插槽</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">B</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.obj.lastName</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">B</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>写法变化，使用v-slot</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">B</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span></span><br><span class="language-xml">        </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">data.obj.lastName</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">B</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用qrcode.vue库生成二维码</title>
    <link href="/Tian-1-2/typblog/2022/10/18/20221018-%E5%88%A9%E7%94%A8qrcode.vue%E5%BA%93%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <url>/Tian-1-2/typblog/2022/10/18/20221018-%E5%88%A9%E7%94%A8qrcode.vue%E5%BA%93%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="利用qrcode-vue库生成二维码"><a href="#利用qrcode-vue库生成二维码" class="headerlink" title="利用qrcode.vue库生成二维码"></a>利用qrcode.vue库生成二维码</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在vue2中</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">npm install --save qrcode.vue<span class="hljs-symbol">@1</span> <span class="hljs-meta"># yarn add qrcode.vue</span><br></code></pre></td></tr></table></figure><p>在vue3中</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">npm install --save qrcode.vue<span class="hljs-symbol">@3</span> <span class="hljs-meta"># yarn add qrcode.vue</span><br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>普通使用：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">import &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br>import QrcodeVue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qrcode.vue&#x27;</span><br><br><span class="hljs-title function_ invoke__">createApp</span>(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;https://example.com&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;qrcode-vue :value=&quot;value&quot;&gt;&lt;/qrcode-vue&gt;&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    QrcodeVue,<br>  &#125;,<br>&#125;).<span class="hljs-title function_ invoke__">mount</span>(<span class="hljs-string">&#x27;#root&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>在组件中使用：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">qrcode-vue</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">:size</span>=<span class="hljs-string">&quot;size&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;H&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">QrcodeVue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qrcode.vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;https://example.com&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">size</span>: <span class="hljs-number">300</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">QrcodeVue</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置项：</strong></p><h3 id="value"><a href="#value" class="headerlink" title="value"></a><code>value</code></h3><ul><li>类型：<code>string</code></li><li>默认值：<code>&#39;&#39;</code></li></ul><p>二维码的内容值，如果这里设置为地址值会直接跳转到该网站</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a><code>size</code></h3><ul><li>类型：<code>number</code></li><li>默认值：<code>100</code></li></ul><p>二维码大小。</p><h3 id="render-as"><a href="#render-as" class="headerlink" title="render-as"></a><code>render-as</code></h3><ul><li>类型：<code>string(&#39;canvas&#39; | &#39;svg&#39;)</code></li><li>默认值：<code>canvas</code></li></ul><p>生成二维码的 HTML 标签，可选 <code>canvas</code> 或 <code>svg</code>。其中 <code>svg</code> 可以用于 SSR。</p><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a><code>margin</code></h3><ul><li>类型：<code>number</code></li><li>默认值：<code>0</code></li></ul><p>定义空白区的宽度应该是多少。</p><h3 id="level"><a href="#level" class="headerlink" title="level"></a><code>level</code></h3><ul><li>类型：<code>string(&#39;L&#39; | &#39;M&#39; | &#39;Q&#39; | &#39;H&#39;)</code></li><li>默认值：<code>H</code></li></ul><p>二维码的容错能力等级，取值为 ‘L’, ‘M’, ‘Q’, ‘H’ 之一。了解更多，<a href="https://en.wikipedia.org/wiki/QR_code#Error_correction">维基百科：QR_code</a>。</p><h3 id="background"><a href="#background" class="headerlink" title="background"></a><code>background</code></h3><ul><li>类型：<code>string</code></li><li>默认值：<code>#ffffff</code></li></ul><p>二维码背景颜色。</p><h3 id="foreground"><a href="#foreground" class="headerlink" title="foreground"></a><code>foreground</code></h3><ul><li>类型：<code>string</code></li><li>默认值：<code>#000000</code></li></ul><p>二维码前景颜色。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a><code>class</code></h3><ul><li>类型：<code>string</code></li><li>默认值：<code>&#39;&#39;</code></li></ul><p>传递给二维码根元素的类名。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="/Tian-1-2/typblog/2022/10/18/20221018-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/Tian-1-2/typblog/2022/10/18/20221018-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h2><p>跨域首先要理解同源策略</p><p><strong>同源策略</strong></p><p>规定：浏览器要求，在解析<a href="https://so.csdn.net/so/search?q=Ajax&spm=1001.2101.3001.7020">Ajax</a>请求时，要求浏览器的路径与Ajax的请求的路径必须满足三个要求，则满足同源策略，可以访问服务器。</p><p>要求：</p><p><strong>协议、域名、端口号都相同，只要有一个不相同，那么都是非同源</strong></p><p>这就要要求到浏览器请求路径、Ajax请求的网址相同</p><p><strong>而跨域就是实现浏览器运行向服务端发送跨域请求，从而克服Ajax只能同源使用的限制</strong></p><p><strong>前端跨域解决方式</strong></p><p>常见的跨域有三种：</p><p>jspn跨域，原理：动态生成script标签，通过script标签引入接口地址(因为script标签不存在跨域的)</p><p>cors跨域(后端开启) ：全称 “跨域资源共享”，原理：它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制</p><p>vue代理服务器proxy跨域：通过请求本地的服务器，然后本地的服务器再去请求远程的服务器(后端部署接口的服务器)，最后本地服务器再将请求回来的数据返回给浏览器(本地服务器和浏览器之前不存在跨域)</p><p>两个关键点：</p><p><strong>本地服务器(利用node.js创建的本地服务器进行代理,也叫代理服务器)和浏览器之间不存在跨域</strong></p><p><strong>服务器和服务器之间不存在跨域</strong></p><p>自己曾在vue项目中配置过</p><p>vue代理服务器proxy跨域：通过请求本地的服务器，然后本地的服务器再去请求远程的服务器(后端部署接口的服务器)，最后本地服务器再将请求回来的数据返回给浏览器(本地服务器和浏览器之前不存在跨域)</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 假设要请求的接口是：http:<span class="hljs-string">//40.00.100.100</span><span class="hljs-function">:3002</span>/api/user/add<br>module.exports = &#123;<br>    devServer:&#123;<br>      host:&#x27;localhost&#x27;,  <span class="hljs-string">//</span> 本地主机<br>        port<span class="hljs-function">:5000</span>,  <span class="hljs-string">//</span> 端口号的配置<br>        open<span class="hljs-function">:true</span>,  <span class="hljs-string">//</span> 自动打开浏览器<br>        proxy:&#123;<br>          &#x27;<span class="hljs-string">/api</span>&#x27;: &#123;   <span class="hljs-string">//</span>  拦截以 <span class="hljs-string">/api</span> 开头的接口<br>            target: &#x27;http:<span class="hljs-string">//40.00.100.100</span><span class="hljs-function">:3002</span>&#x27;,<span class="hljs-string">//</span>设置你调用的接口域名和端口号 别忘了加http<br>            changeOrigin: <span class="hljs-literal">true</span>,    <span class="hljs-string">//</span>这里<span class="hljs-literal">true</span>表示实现跨域<br>            secure: <span class="hljs-literal">false</span>, <span class="hljs-string">//</span> 如果是https接口，需要配置这个参数<br>            pathRewrite: &#123;<br>              &#x27;^<span class="hljs-string">/api</span>&#x27;:&#x27;/&#x27;  <span class="hljs-string">//</span>这里理解成用‘<span class="hljs-string">/api</span>’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用&#x27;http:<span class="hljs-string">//40.00.100.100</span><span class="hljs-function">:3002</span>/api/user/add&#x27;，直接写‘<span class="hljs-string">/api/user/add</span>’即可<br>            &#125;<br>          &#125;,<br><span class="hljs-string">//</span> 假如又有一个接口是：http:<span class="hljs-string">//40.00.100.100</span><span class="hljs-function">:3002</span>/get/list/add<br><span class="hljs-string">//</span> 那就再配置一个 get的，如下：<br>          &#x27;<span class="hljs-string">/get</span>&#x27;: &#123;   <span class="hljs-string">//</span>  拦截以 <span class="hljs-string">/get</span> 开头的接口<br>            target: &#x27;http:<span class="hljs-string">//40.00.100.100</span><span class="hljs-function">:3002</span>&#x27;,<span class="hljs-string">//</span>设置你调用的接口域名和端口号 别忘了加http<br>            changeOrigin: <span class="hljs-literal">true</span>,    <span class="hljs-string">//</span>这里<span class="hljs-literal">true</span>表示实现跨域<br>            secure: <span class="hljs-literal">false</span>, <span class="hljs-string">//</span> 如果是https接口，需要配置这个参数<br>            pathRewrite: &#123;<br>              &#x27;^<span class="hljs-string">/api</span>&#x27;:&#x27;/&#x27;  <span class="hljs-string">//</span>这里理解成用‘<span class="hljs-string">/api</span>’代替target里面的地址，<br>            &#125;<br>          &#125;<br>         <span class="hljs-string">//</span> 调用的时候直接  <span class="hljs-string">/get/list/add</span>  就可以了<br>        &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-string">//</span> 注意：修改了配置文件后一定要重启才会生效;<br></code></pre></td></tr></table></figure><p>代理跨域的主要方式是利用服务器请求服务器的方式避过跨域问题来实现的.大概的流程: 浏览器&#x3D;&#x3D;&#x3D;&gt;代理服务器&#x3D;&#x3D;&#x3D;&gt;目标服务器.</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称加密，非对称加密以及Https加密</title>
    <link href="/Tian-1-2/typblog/2022/10/18/20221018-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8AHttps%E5%8A%A0%E5%AF%86/"/>
    <url>/Tian-1-2/typblog/2022/10/18/20221018-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8AHttps%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a><strong>对称加密：</strong></h2><p><a href="https://so.csdn.net/so/search?q=%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">对称加密</a>是指，加密方和解密方使用同样的秘钥来进行加密和解密。</p><p>在对称加密算法中，数据发信方将明文（ <a href="http://baike.baidu.com/view/3364695.htm">原始数据</a> ）和<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">加密</a> <a href="http://baike.baidu.com/view/934.htm">密钥</a> （mi yue）一起经过特殊<a href="https://so.csdn.net/so/search?q=%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">加密算法</a>处理后，使其变成复杂的加密密文发送出去。</p><p>常用的对称加密算法：AES，RC4，3DES</p><p><strong>传输的示意图如下所示：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201016091617212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjM5NzY1,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="非对称加密："><a href="#非对称加密：" class="headerlink" title="非对称加密："></a><strong>非对称加密：</strong></h2><p><strong>非对称加密算法实现机密信息交换的基本过程是：</strong></p><ol><li>甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；</li><li>得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；</li><li>甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。</li><li>甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</li></ol><p><a href="https://so.csdn.net/so/search?q=%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">非对称加密</a>算法：RSA，DSA&#x2F;DSS </p><p><strong>用通俗易懂的话来解释非对称加密:</strong></p><p>看一个小时候经常在《趣味数学》这类书里的一个数学小魔术：</p><p>让对方任意想一个3位数，并把这个数和91相乘，然后告诉我积的最后三位数，我就可以猜出对方想的是什么数字啦！比如对方想的是123，那么对方就计算出123 * 91等于11193，并把结果的末三位193告诉我。看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。不过，我仍然有办法：只需要把对方告诉我的结果再乘以11，乘积的末三位就是对方刚开始想的数了。可以验证一下，193 * 11 &#x3D; 2123，末三位正是对方所想的秘密数字！</p><p>其实道理很简单，91乘以11等于1001，而任何一个三位数乘以1001后，末三位显然都不变（例如123乘以1001就等于123123）。</p><p>知道原理后，我们可以构造一个定义域和值域更大的加密解密系统。比方说，任意一个数乘以400000001后，末8位都不变，而400000001 &#x3D; 19801 * 20201，于是你来乘以19801，我来乘以20201，又一个加密解密不对称的系统就构造好了。</p><p>甚至可以构造得更大一些：4000000000000000000000000000001 &#x3D; 1199481995446957 * 3334772856269093，这样我们就成功构造了一个30位的加密系统。</p><p>这是一件非常coooooooool的事情，任何人都可以按照我公布的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。</p><p>其安全性就建立在算乘积非常容易，但是要把4000000000000000000000000000001分解成后面两个数相乘，在没有计算机的时代几乎不可能成功！但如果仅仅按照上面的思路，如果对方知道原理，知道我要构造出带很多0的数，根据19801和8位算法这2个条件非常容易穷举出400000001这个目标值。</p><p>要解决这个问题，真实世界就不是使用乘法了，比如RSA算法使用的是指数和取模运算，但本质上就是上面这套思想。</p><p><strong>传输的示意图如下所示：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201016091004330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjM5NzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：</p><p>公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容。</p><h2 id="非对称和对称完美结合"><a href="#非对称和对称完美结合" class="headerlink" title="非对称和对称完美结合"></a><strong>非对称和对称完美结合</strong></h2><p>非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势：</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210191734400.png" alt="20180413131856736"></p><p>如上图所示</p><ol><li>第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器</li><li>服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密</li><li>后续两者之间信息的传输就可以使用对称加密的方式了</li></ol><p>这是个非常非常经典的数据传输过程，也是Https传输协议里面最经典的部分。也是把对称加密和非对称加密的作用发挥到了很好的地方。在https传输的过程中，如果单独只用对称加密，或者单独使用非对称加密都会出现问题。</p><p>本文转载自：<a href="https://blog.csdn.net/qq_42239765/article/details/109102092">https://blog.csdn.net/qq_42239765/article/details/109102092</a></p><br>这个时候差不多对加密方式有些了解了吧，刚开始一开始了解https的加密方式我也是一头雾水，原来是对称加密和非对称加密的结合。<p>但是还是有些缺陷，再加上ssl证书就完美了</p><p>这边再推荐一个大佬的文章，讲的更加细致，https整个加密过程，包括每一步的细节都讲解出来了</p><p><a href="https://zhuanlan.zhihu.com/p/43789231">https://zhuanlan.zhihu.com/p/43789231</a></p><p><strong>这里我简单的概括一下Https的加密过程</strong>：</p><p>首先客户端使用https url访问服务器时，要求服务器建立ssl链接</p><p>服务器收到请求之后，会把网站的证书（包含了公钥），传输给客户端</p><p>这时候客户端和服务器开始商量ssl链接的安全等级，也就是加密等级</p><p>而达成一致后，客户端的浏览器会通过双方达成一致的安全等级，建立起会话密钥，然后通过网站的公钥，来加密会话密钥，并传送给服务器</p><p>然后服务器会通过自己的私钥解密出会话密钥</p><p>服务器就通过会话密钥加密与客户端之前的通信</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破解版Typora及将图片上传到图床</title>
    <link href="/Tian-1-2/typblog/2022/10/14/20221014-%E7%A0%B4%E8%A7%A3%E7%89%88Typora%E5%8F%8A%E5%B0%86%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9B%BE%E5%BA%8A/"/>
    <url>/Tian-1-2/typblog/2022/10/14/20221014-%E7%A0%B4%E8%A7%A3%E7%89%88Typora%E5%8F%8A%E5%B0%86%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="破解版Typora及将图片上传到图床"><a href="#破解版Typora及将图片上传到图床" class="headerlink" title="破解版Typora及将图片上传到图床"></a>破解版Typora及将图片上传到图床</h2><p>为了解决在Typora编辑图片后上传博客时，博客图片消失的问题，可以进行下面的操作</p><h4 id="破解版Typora"><a href="#破解版Typora" class="headerlink" title="破解版Typora"></a>破解版Typora</h4><p>typora下载及激活<br>链接：<a href="https://pan.baidu.com/s/12Y6t51m6cYe21niiLQRxpg?pwd=znbw">https://pan.baidu.com/s/12Y6t51m6cYe21niiLQRxpg?pwd=znbw</a><br>提取码：znbw</p><p>解压缩后将winmm.dll文件放入安装目录即可</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210141214993.png" alt="image-20221014121446955"></p><h4 id="上传到图床"><a href="#上传到图床" class="headerlink" title="上传到图床"></a>上传到图床</h4><p>这里我采用的是利用PicGo+Gitee实现的</p><p>这里是大佬的安装链接 <a href="https://zhuanlan.zhihu.com/p/412422531">https://zhuanlan.zhihu.com/p/412422531</a></p><p>已经讲的很详细了，但有一些坑需要注意一下</p><p>首先PicGo我选择的是 </p><p>这个版本的： 下载链接：<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210141157963.png" alt="image-20221014115738940"></p><p>其次是在配置gittee设置时</p><p>repo中的内容配置的是所创建仓库地址gitee.com&#x2F;后的内容</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210141200717.png" alt="image-20221014120040689"></p><p>而且在部署到博客上时会发现图片仍然不显示这时候需要在文章开头加上以下代码就行了<br><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>各种配置</category>
      
      <category>Typora</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建与更新</title>
    <link href="/Tian-1-2/typblog/2022/10/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <url>/Tian-1-2/typblog/2022/10/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="如何搭建博客"><a href="#如何搭建博客" class="headerlink" title="如何搭建博客"></a>如何搭建博客</h4><p>搭建博客主教程：</p><p><a href="https://www.cnblogs.com/huanhao/p/hexobase.html#%E7%94%9F%E6%88%90%E6%96%87%E7%AB%A0%E7%9A%84%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7">https://www.cnblogs.com/huanhao/p/hexobase.html#%E7%94%9F%E6%88%90%E6%96%87%E7%AB%A0%E7%9A%84%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7</a></p><p>部署到gitee：</p><p><a href="https://blog.csdn.net/qq_60700961/article/details/125978581?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9C%A8gitte%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-125978581.142">https://blog.csdn.net/qq_60700961&#x2F;article&#x2F;details&#x2F;125978581?ops_request_misc&#x3D;&amp;request_id&#x3D;&amp;biz_id&#x3D;102&amp;utm_term&#x3D;%E5%9C%A8gitte%E4%B8%8A%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-125978581.142</a>^v52^js_top,201^v3^control_1&amp;spm&#x3D;1018.2226.3001.4187</p><p>部署到github：</p><p><a href="https://blog.csdn.net/labeaze/article/details/122797869">https://blog.csdn.net/labeaze/article/details/122797869</a></p><p>这个地方有一个坑：</p><p>部署到github中需要修改_config.yml中的url地址<br>如下：<br>    url: <a href="http://tian-1-2.github.io/typblog.github.io">http://tian-1-2.github.io/typblog.github.io</a><br>需要改为你仓库地址能让它加载到对应的文件</p><p>Fluid主题配置信息：</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><p>开启评论等功能：</p><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166564717816782248526380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166564717816782248526380&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-12-119089190-null-null.142%5Ev55%5Ejs_top,201%5Ev3%5Econtrol_1&amp;utm_term=%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2Hexo%20Fluid%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%A1%B5%E9%9D%A2&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/yaorongke/article/details/119089190?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166564717816782248526380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166564717816782248526380&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-12-119089190-null-null.142^v55^js_top,201^v3^control_1&amp;utm_term=%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2Hexo%20Fluid%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%A1%B5%E9%9D%A2&amp;spm=1018.2226.3001.4187</a></p><h4 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h4><p>hexo g -d上传远程仓库</p><p>hexo s 本地启动</p>]]></content>
    
    
    <categories>
      
      <category>各种配置</category>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue组件封装技巧</title>
    <link href="/Tian-1-2/typblog/2022/10/13/vue%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7/"/>
    <url>/Tian-1-2/typblog/2022/10/13/vue%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>[TOC]</p><h2 id="vue组件封装技巧"><a href="#vue组件封装技巧" class="headerlink" title="vue组件封装技巧"></a>vue组件封装技巧</h2><h4 id="1-props参数"><a href="#1-props参数" class="headerlink" title="1.props参数"></a>1.props参数</h4><p>最简单父传子的技巧，在父组件传入值，子组件声明props接收就可以了</p><p>如下：</p><p>父组件：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;外面调用的&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Table</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Table.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-xquery">  components: &#123;</span><br><span class="language-xquery">    Table</span><br><span class="language-xquery">&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">content</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;content&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父亲过来的&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">$attrs</span>);   </span></span><br><span class="language-javascript"><span class="language-xml">     &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上面是用的props的数组语法，下面是对象语法，做更近一步处理时可以使用</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">props:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class="hljs-symbol">    propA:</span> Number,<br><br>    <span class="hljs-comment">// 多个可能的类型</span><br><span class="hljs-symbol">    propB:</span> [String, Number],<br><br>    <span class="hljs-comment">// 必填的字符串</span><br><span class="hljs-symbol">    propC:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      type:</span> String,<br><span class="hljs-symbol">      required:</span> true,<br>    <span class="hljs-punctuation">&#125;</span>,<br><br>    <span class="hljs-comment">// 带有默认值的数字</span><br><span class="hljs-symbol">    propD:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      type:</span> Number,<br><span class="hljs-symbol">      default:</span> <span class="hljs-number">100</span>,<br>    <span class="hljs-punctuation">&#125;</span>,<br><br>    <span class="hljs-comment">// 具有默认值的数组写法</span><br><span class="hljs-symbol">    propK:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      type:</span> Array,<br>      <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span><br><span class="hljs-symbol">      default:</span> function () <span class="hljs-punctuation">&#123;</span><br>        return [<span class="hljs-string">&quot;张三&quot;</span>]<span class="hljs-punctuation">;</span><br>      <span class="hljs-punctuation">&#125;</span>,<br>    <span class="hljs-punctuation">&#125;</span>,<br><br>    <span class="hljs-comment">// 带有默认值的对象</span><br><span class="hljs-symbol">    propE:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      type:</span> Object,<br>      <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span><br><span class="hljs-symbol">      default:</span> function () <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-title class_">return</span> <span class="hljs-punctuation">&#123;</span> message: <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-punctuation">&#125;;</span><br>      <span class="hljs-punctuation">&#125;</span>,<br>    <span class="hljs-punctuation">&#125;</span>,<br><br>    <span class="hljs-comment">// 自定义验证函数</span><br><span class="hljs-symbol">    propF:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      validator:</span> function (value) <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>        return [<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-string">&quot;danger&quot;</span>].indexOf(value) !== <span class="hljs-number">-1</span><span class="hljs-punctuation">;</span><br>      <span class="hljs-punctuation">&#125;</span>,<br>    <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-punctuation">&#125;</span>,<br></code></pre></td></tr></table></figure><h4 id="2-attrs"><a href="#2-attrs" class="headerlink" title="2.$attrs"></a>2.$attrs</h4><p><strong>用途</strong>：在对组件进行二次封装的时候会出现孙子组件的传值问题，如果都通过prop进行层层传递太过麻烦，可以选择不使用props传值而通过$attrs传递</p><p><strong>定义</strong>：包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 props 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件——在创建更高层次的组件时非常有用。</p><p><strong>用法</strong>：父组件正常传入数据，子组件通过在孙组件上v-bind&#x3D;:”$attrs”将未props声明的数据传递，孙组件通过this.$atrs.xxx进行使用</p><p>父组件：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;外面调用的&quot;</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;这是测试attrs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Table</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Table.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-xquery">  components: &#123;</span><br><span class="language-xquery">    Table</span><br><span class="language-xquery">&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">this.$attrs.content</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;&#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父亲过来的&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$attrs</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>打印台信息：</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210141354645.png" alt="image-20221014135456615"></p><p>但这有一个需要注意的点：$attrs将propos未声明的属性会作为HTML属性绑定到组件的根元素上</p><p>这时候需要添加：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">inheritAttrs:</span><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210141417699.png" alt="image-20221014141754671"></p><h4 id="3-emit"><a href="#3-emit" class="headerlink" title="3.$emit"></a>3.$emit</h4><p>可以用于子组件向父组件传递消息，触发定义的事件</p><p>父组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">last</span> @<span class="hljs-attr">msgA</span>=<span class="hljs-string">&quot;msgA&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">last</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> last <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/last.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>:&#123;</span><br><span class="language-javascript">    last</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">msgA</span>(<span class="hljs-params">name</span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;事件被调用了&quot;</span>,name);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;msgA&#x27;</span>,<span class="hljs-string">&#x27;sssss&#x27;</span>)   </span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到控制台输出的内容</p><p><img src="C:/Users/test/AppData/Roaming/Typora/typora-user-images/image-20221019142634683.png" alt="image-20221019142634683"></p><h4 id="4-listeners"><a href="#4-listeners" class="headerlink" title="4.$listeners"></a>4.$listeners</h4><p>与 $attrs的用法类似，当我们需要将事件处理函数传递给子组件时，可以利用父组件实例上的 $listeners属性，这个属性包含了组件接收到的事件处理函数,需要在子组件上绑定：v-on&#x3D;”$listeners”</p><p>父组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">last</span> @<span class="hljs-attr">msgA</span>=<span class="hljs-string">&quot;msgA&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">last</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> last <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/last.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>:&#123;</span><br><span class="language-javascript">    last</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">msgA</span>(<span class="hljs-params">name</span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;事件被调用了&quot;</span>,name);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;msgA&#x27;</span>,<span class="hljs-string">&#x27;sssss&#x27;</span>)</span><br><span class="language-javascript">        </span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父亲过来的值&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$attrs</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父亲传过来的事件&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">$listeners</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$listeners</span>.<span class="hljs-title function_">msgA</span>(<span class="hljs-string">&#x27;sdddddddd&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到控制台打印的信息</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210191437275.png" alt="image-20221019143754249"></p><p><strong>简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。</strong></p><h4 id="5-插槽"><a href="#5-插槽" class="headerlink" title="5.插槽"></a>5.插槽</h4><p>一个通用组件，往往不能够适应所有应用场景，所以在封装组件的时候只需要完成组件 80% 的功能，剩下的 20% 让父组件通过 solt 解决。比如：某一个公共组件中有两个按钮，一个是“新增”，一个是“删除”，但是在另外的场景中使用这个组件时，两个按钮需要做的事情是不一样的，比如是“查看”和“修改”。所以，我们在封装组件的时候就不要直接写按钮了，而是在合适的位置放置一个slot，其实是一个占位的作用，给按钮的设置提前预留一个位置，然后在父组件中写入按钮即可。<br>具体插槽如何使用我之前发过一篇文章，见下方链接<br><a href="https://blog.csdn.net/qq_49907632/article/details/127575530?spm=1001.2014.3001.5502">插槽</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的生命周期</title>
    <link href="/Tian-1-2/typblog/2022/10/10/20221010-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/Tian-1-2/typblog/2022/10/10/20221010-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="Vue2生命周期"><a href="#Vue2生命周期" class="headerlink" title="Vue2生命周期"></a>Vue2生命周期</h2><p>废话不多说，先直接上图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccd16fe2d1942e699bde7a7971c26a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="生命周期.webp"></p><p>图上已经描绘的很清楚了，接下来我再总结一下：</p><p>首先创建一个vue实例</p><p>然后会初始化这个实例的所有的生命周期函数</p><p>接着会进行第一个生命周期<strong>beforecreate</strong>，这时只是初始化完成了主要的生命周期函数而已，实例中的data和methods尚未初始化</p><p>然后会进行<strong>created</strong>,这时data和methods已经初始化好了；一般在这里会发送Ajax请求</p><p>接着会进行编译vue的指令，同时渲染HTML结构，生成虚拟dom，但是还没有渲染到页面上</p><p>然后会进行第三个生命周期函数<strong>beforeMount</strong>，这时候将要把内存中的HTML结构渲染到页面上，但是还没有真正的渲染，所以页面上还是空白的，不能操作dom</p><p>接着是第四个生命周期<strong>mounted，</strong>也创建阶段最后一个生命周期，此时对dom的操作都有效，可以在此初始化一些js的插件</p><p>然后当data中的数据发生变化时，会依次调用beforeUpdate和update</p><p>首先<strong>beforeUpdate</strong>时<strong>，</strong>表示data中的数据已经发生了变化，data数据已经是最新的了，但是，用户看到的页面上的数据依然是老数据</p><p>接着<strong>updated</strong>表示页面已经完成了更新，此时页面和data但是最新的</p><p>最后当组件被销毁时，也会触发两个生命周期</p><p>首先<strong>beforDestroy</strong>表示vm实例即将被摧毁，所以此时vm实例还存在，可以在此时做一些收尾操作，比如关闭定时器，取消订阅消息，解绑自定义事件等</p><p><strong>destoryed</strong>表示此时vm实例已经被摧毁了，无法正常工作了</p><p>接下来讲讲vue3的生命周期，基本上与vue2类似</p><h2 id="Vue3生命周期"><a href="#Vue3生命周期" class="headerlink" title="Vue3生命周期"></a>Vue3生命周期</h2><p>还是直接上图</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210171612019.png" alt="image-20221017161205953"></p><p>直接接拿来与Vue2对比一下就很清晰看出区别了：</p><table><thead><tr><th>Vue2生命周期</th><th>Vue3生命周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup()</td></tr><tr><td>created</td><td>setup()</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>onUnmounted</td></tr></tbody></table><p>以及特殊钩子</p><table><thead><tr><th>Vue2</th><th>Vue 3</th></tr></thead><tbody><tr><td>activated</td><td>deactivated</td></tr><tr><td>onActivated</td><td>onDeactivated</td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td></tr></tbody></table><p>​<br>​<br>​<br>​</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url到页面展示出来的全过程</title>
    <link href="/Tian-1-2/typblog/2022/10/09/2022109-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/Tian-1-2/typblog/2022/10/09/2022109-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器输入url到页面展示出来的全过程"><a href="#浏览器输入url到页面展示出来的全过程" class="headerlink" title="浏览器输入url到页面展示出来的全过程"></a>浏览器输入url到页面展示出来的全过程</h2><h4 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h4><h5 id="1、用户在浏览器中输入url地址"><a href="#1、用户在浏览器中输入url地址" class="headerlink" title="1、用户在浏览器中输入url地址"></a>1、用户在浏览器中输入url地址</h5><h5 id="2、浏览器解析域名得到服务器ip地址"><a href="#2、浏览器解析域名得到服务器ip地址" class="headerlink" title="2、浏览器解析域名得到服务器ip地址"></a>2、浏览器解析域名得到服务器ip地址</h5><p>解析域名的过程如下：</p><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p><ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul></li><li><p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p><p>流程图如下：</p><p><img src="https://static.vue-js.com/bec3c740-b78f-11eb-ab90-d9ae814b240d.png" alt="img"></p></li></ul><h5 id="3、TCP三次握手建立客户端和服务器的连接"><a href="#3、TCP三次握手建立客户端和服务器的连接" class="headerlink" title="3、TCP三次握手建立客户端和服务器的连接"></a>3、TCP三次握手建立客户端和服务器的连接</h5><p>因为HTTP是基于TCP的可靠传输，所以在发送http数据报之前，需要先进行TCP的三次握手建立连接。三次握手过程如下：</p><p>第一次握手：客户端—&gt;服务端 ack&#x3D;1,seq&#x3D;x（x随机生成）</p><p>第二次握手：服务端—&gt;客户端 ACK&#x3D;1,ack&#x3D;x+1,seq&#x3D;y（y随机生成）</p><p>第三次握手：客户端—&gt;服务端 ACK&#x3D;1,ack&#x3D;y+1,seq&#x3D;x+1</p><p>完成第三次握手时，实际上客户端已经与服务器建立了连接，所以第三次握手的报文已经可以携带数据了。</p><h5 id="4、客户端发送HTTP请求获取服务器端的静态资源"><a href="#4、客户端发送HTTP请求获取服务器端的静态资源" class="headerlink" title="4、客户端发送HTTP请求获取服务器端的静态资源"></a>4、客户端发送HTTP请求获取服务器端的静态资源</h5><h5 id="5、服务器发送HTTP响应报文给客户端，客户端获取到页面静态资源"><a href="#5、服务器发送HTTP响应报文给客户端，客户端获取到页面静态资源" class="headerlink" title="5、服务器发送HTTP响应报文给客户端，客户端获取到页面静态资源"></a>5、服务器发送HTTP响应报文给客户端，客户端获取到页面静态资源</h5><h5 id="6、TCP四次挥手关闭客户端和服务器的连接"><a href="#6、TCP四次挥手关闭客户端和服务器的连接" class="headerlink" title="6、TCP四次挥手关闭客户端和服务器的连接"></a>6、TCP四次挥手关闭客户端和服务器的连接</h5><p>数据传输完毕后，TCP会进行四次挥手断开连接，释放资源。四次挥手过程如下：</p><p>第一次挥手：客户端—&gt;服务器 FIN&#x3D;1,ack&#x3D;1,seq&#x3D;u 客户端状态变为FIN_WAIT_1</p><p>第二次挥手：服务器—&gt;客户端 ACK&#x3D;1,ack&#x3D;u+1,seq&#x3D;v 服务器状态变为CLOSE_WAIT，TCP进入半关闭状态</p><p>第三次挥手：服务器—&gt;客户端 FIN&#x3D;1,ACK&#x3D;1,ack&#x3D;u+1,seq&#x3D;w 服务器状态变为LAST_ACK</p><p>第四次挥手：客户端—&gt;服务器 ACK&#x3D;1,ack&#x3D;w+1,seq&#x3D;u+1 客户端状态变为TIME_WAIT，此时TCP未释放，需要等待计时器计时完成后，客户端状态变为CLOSED</p><h5 id="7、浏览器解析文档资源并渲染页面"><a href="#7、浏览器解析文档资源并渲染页面" class="headerlink" title="7、浏览器解析文档资源并渲染页面"></a>7、浏览器解析文档资源并渲染页面</h5><p>浏览器解析文档资源并渲染页面流程：</p><p>（1）解析html资源，构建DOM Tree</p><p>（2）解析css资源，构建CSS Rule Tree</p><p>（3）JS通过DOM API和CSS OM API来操作DOM Tree和CSS Tree</p><p>（4）解析完成后综合DOM Tree和CSS Tree会生成Render Tree，计算每个元素的位置，这个过程就是回流（layout or reflow）</p><p>（5）调用操作系统Native GUI的绘制</p><p>（6）页面绘制完成</p><h4 id="涉及到的其他知识点："><a href="#涉及到的其他知识点：" class="headerlink" title="涉及到的其他知识点："></a>涉及到的其他知识点：</h4><h5 id="1、Render-Tree的生成"><a href="#1、Render-Tree的生成" class="headerlink" title="1、Render Tree的生成"></a>1、Render Tree的生成</h5><p>DOM Tree和CSS Tree结合会生成Render Tree，是由可视化元素按照其顺序生成的树形结构，非可视化元素是不会出现到渲染树中的。</p><p>非可视化元素：head、display：none；（注意：visibility：hidden的元素会出现在渲染树中）</p><h5 id="2、回流和重绘"><a href="#2、回流和重绘" class="headerlink" title="2、回流和重绘"></a>2、回流和重绘</h5><p>回流（reflow，也叫重排、布局）：某部分的变化影响了布局，浏览器需要重新渲染。（如元素大小、位置的改变）</p><p>重绘（repaint）：元素的某一部分发生改变，尺寸、位置没有改变。（字体颜色、背景颜色的改变）</p><p>引起回流的几个主要原因：</p><p>（1）网页初始化</p><p>（2）JS操作DOM树（增加、删除元素等）</p><p>（3）某些元素的尺寸改变</p><p>（4）CSS属性的改变</p><p>浏览器的“dirty”系统：</p><p>为了避免页面细小的改变就引起回流和重绘，“dirty”系统会将这些改变操作积攒一批再进行操作，这又叫异步reflow或者增量异步reflow。有些特殊情况不会这么做：resize窗口、改变了页面默认的字体等，这些操作会直接触发回流。</p><p>编写代码时如何减少回流和重绘：</p><p>（1）修改样式不要逐条修改，定义CSS样式的class，直接修改元素的className</p><p>（2）不要将DOM节点的属性值放在循环中当成循环的变量</p><p>（3）为动画的HTML元素使用fixed或absolute的position属性，修改它们的CSS就不会触发reflow</p><p>（4）把DOM离线后修改，设置display：none或者clone元素到内存中，修改完成再显示回页面</p><p>（5）不要使用table布局，一个微小的改变就可能引起整个table的重新布局</p><h5 id="3、性能优化"><a href="#3、性能优化" class="headerlink" title="3、性能优化"></a>3、性能优化</h5><p>（1）提升HTML的加载速度</p><ul><li><p>页面精简，删除不必要的内容，将内嵌的JS和CSS移至外部文件，使用压缩工具等</p></li><li><p>减少文件数量，合并文件，减少请求次数</p></li><li><p>减少域名查询，外部引入的资源尽量少使用不同的域名</p></li><li><p>使用缓存，重用数据</p></li><li><p>优化页面元素的加载顺序</p></li><li><p>使用合法的标签</p></li><li><p>根据浏览器类型选择合适的策略</p></li></ul><p>（2）编写合理的CSS</p><ul><li><p>DOM的深度尽量浅</p></li><li><p>使用合法的CSS属性</p></li><li><p>不要为ID选择器指定类名或标签名</p></li><li><p>避免使用后代选择器，尽量使用子选择器</p></li><li><p>避免使用通配符</p></li></ul><p>（3）关于JS标签</p><ul><li><p>js标签的加载和执行特点：载入后立即执行，执行时会阻塞页面后续内容</p></li><li><p>将所有的js标签放在页面底部，保证脚本执行前已完成DOM渲染</p></li><li><p>尽可能合并脚本</p></li><li><p>减少内联js的使用</p></li><li><p>注意多个js标签的引入顺序</p></li><li><p>使用defer属性，该属性可以使脚本在文档完全呈现以后再执行</p></li><li><p>使用async属性，可以使当前脚本不必等待其他脚本的执行，也不必阻塞文档的呈现</p></li></ul><p><strong>这里再对defer和async做一下细致的划分</strong></p><p>正常情况下script会阻碍HTML解析，等script下载完毕且执行完后才会继续解析HTML</p><p>而defer与async 都不会阻碍HTML解析（异步加载）</p><p>他们的区别在与：</p><ul><li>async 执行与文档顺序无关，先加载哪个就先执行哪个；defer会按照文档中的顺序执行</li><li>async 脚本加载完成后立即执行，可以在DOM尚未完全下载完成就加载和执行；而defer脚本需要等到文档所有元素解析完成之后才执行</li><li>可以概括：async:谁先加载完谁执行   defer：先下载 等dom加载完后再按顺序执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再去雨花台</title>
    <link href="/Tian-1-2/typblog/2022/10/07/2022107-%E5%86%8D%E5%8E%BB%E9%9B%A8%E8%8A%B1%E5%8F%B0/"/>
    <url>/Tian-1-2/typblog/2022/10/07/2022107-%E5%86%8D%E5%8E%BB%E9%9B%A8%E8%8A%B1%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="再去雨花台"><a href="#再去雨花台" class="headerlink" title="再去雨花台"></a>再去雨花台</h2><p>刚从雨花台回来，想躺下睡个觉，想了一会，我怕一觉睡到天黑，算了不睡了，忽然想到要不写点什么？<br>高中时期书生意气，最想动笔写些什么，可是想来想去没有任何经历，能写些什么呢？到最后变成了空文。<br>大学时期，时间有了，经历有了，可是心境却变了。如今，实在没事干的我终于想提起笔写些什么了，不对，如今我也早把笔换成了键盘，更没有提笔这一说了，只能说键来哈哈哈哈。</p><p>时隔六年，我再次来到了雨花台。<br>记忆已经有些模糊了，许多地方我都看着特别陌生，不知道是这六年期间雨花台是新建了景点，还是我当时没有注意到，或是我就已经完全遗忘了。<br>刚进去，一阵桂花香扑过来，完蛋了。我把口罩摘下来，我不管，我不管，我就要闻，我太爱桂花了。之前学习在新乡园区偶然闻到了桂花香，可是找了好久都没找到。今天终于让我逮住了吧。<br>接着往前路，一个上坡的柏油路，两边还有参天的梧桐树，这个印象倒挺深，六年前好像谁的钥匙什么的掉了在这找，具体的也记不清了。其实印象最深的就是纪念碑了吧，纪念碑下有许多白鸽，当年是谁拿着食物喂它们，然后身上站满了白鸽。<br>可是今天过去的时候，没有见到一个白鸽，不知道是因为习性现在不是在这的时候，还是这已经根本已经没有白鸽了。<br>我靠着栏杆，翻了翻我以前的照片，看着我青雉的脸，简直就像跨时空与六年前的我进行交流，当时的我可能想都没想过，六年后我会再次站到这。<br>然后我再往前走，我发现了我记忆中没有出现的景点，真的一点印象都没有，真的怀疑我是不是没来过这个地方，下面的放了几张图片，高一的同学帮我回想一下，这些当时真的有吗？</p><p>时隔六年，倒是不如说我再次来到了南京。<br>上次是旅游，这次是工作。仿佛就是理想面对了现实。<br>来的第一天，不行，我自己一个人太孤独了我要回去我待不下去了。<br>来的第二天，算了凑合一个月吧，把房租挣回来。<br>来的第三天，算了干到过年吧，再忍忍吧。<br>终究感觉自己还是败给了现实。等到正式上班会好一点了是吧，对吧会好一些。<br>我也又去旅游了，我去景点转了，可是感觉就是不一样了。来之前我认为我把之前转过的景点再转一遍感觉很有意义。<br>但是目前我已经感觉不到了，<br>六年前我感觉哪都可新鲜，想到处跑<br>六年后我只感觉到累，我想快速的走过去。<br>即便会偶尔勾起我的回忆，但其实并不快乐。<br>计划提前终止，剩下的景区，等以后想去了再慢慢转吧。</p><p>之前看大冰书，天天听大冰说：“不要那么孤独，这世界上真的有人过着你想过的生活。”<br>……<br>然后呢？突然感觉很讽刺。</p><p>我感觉我是个理想主义者，理想会照进现实。可是理想真正的到了现实，却发现这好像不是当初的理想了。<br>也有人说我感性，但因此犹犹豫豫患得患失做错了好多选择。</p><p>会后悔吗，当然会<br>那为什么还要走，因为到死之前我们都是需要发育的孩子（狗头）。<br>为什么突然不悲观了，因为刚刚歌曲循环到张韶涵的《篇章》了，燃起来了哈哈哈哈</p><p>命运深处涌动着更多浪漫<br>梦想破土生长更多答案<br>繁星背后太阳已开始绚烂<br>谢谢你与我作伴</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指向，call、apply、bind详解</title>
    <link href="/Tian-1-2/typblog/2022/10/02/this%E6%8C%87%E5%90%91%EF%BC%8Ccall%E3%80%81apply%E3%80%81bind%E8%AF%A6%E8%A7%A3/"/>
    <url>/Tian-1-2/typblog/2022/10/02/this%E6%8C%87%E5%90%91%EF%BC%8Ccall%E3%80%81apply%E3%80%81bind%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="this指向，call、apply、bind详解"><a href="#this指向，call、apply、bind详解" class="headerlink" title="this指向，call、apply、bind详解"></a>this指向，call、apply、bind详解</h2><p>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的<code>执行环境</code>动态绑定的，而非函数被声明时的环境；</p><p>具体在实际应用中，this指向大概可以分为以下几种</p><h4 id="1-作为对象的方法调用"><a href="#1-作为对象的方法调用" class="headerlink" title="1.作为对象的方法调用"></a>1.作为对象的方法调用</h4><p>当函数作为对象的方法被调用时，this指向该对象</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this === obj);<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>    &#125;<br>&#125;;<br><br>obj.getName(); <span class="hljs-comment">// true &#x27;test&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-作为普通函数调用时"><a href="#2-作为普通函数调用时" class="headerlink" title="2.作为普通函数调用时"></a>2.<strong>作为普通函数调用时</strong></h4><p>当函数不作为对象的属性被调用，而是以普通函数的方式，this总是指向全局对象（在浏览器中，通常是Window对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;test&#x27;</span>;<br><br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// test</span><br><br></code></pre></td></tr></table></figure><p>这里有一个迷惑性的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;老王&#x27;</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;yuguang&#x27;</span>,<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> getNew = obj.<span class="hljs-property">getName</span>;<br><span class="hljs-title function_">getNew</span>(); <span class="hljs-comment">// 老王</span><br></code></pre></td></tr></table></figure><p>这里的getNew相当于一个函数调用了，而不是对象中的方法</p><h4 id="3-构造器调用"><a href="#3-构造器调用" class="headerlink" title="3.构造器调用"></a>3.构造器调用</h4><p>除了一些内置函数，大部分Js中的函数都可以成为构造器，它们与普通函数没什么不同</p><p><strong>构造器</strong>和<strong>普通函数</strong>的区别在于<strong>被调用的方式</strong>：<br>当new运算符调用函数时，总是返回一个对象，this通常也指向这个对象</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> MyClass = <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;tian&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> MyClass();<br>obj.name; <span class="hljs-comment">// tina</span><br></code></pre></td></tr></table></figure><p>但是，如果显式的返回了一个object对象，那么此次运算结果最终会返回这个对象。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> MyClass = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    this.name = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> myClass = <span class="hljs-keyword">new</span> MyClass(); <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;myClass:&#x27;</span>, myClass); <span class="hljs-comment">// &#123; name: 2&#125;</span><br></code></pre></td></tr></table></figure><p>只要构造器不显示的返回任何数据，或者返回非对象类型的数据，就不会造成上述问题。<br>这里就涉及到new的实现过程了，之前的博客写过了，这里不再赘述，请参考</p><p><a href="https://tian-1-2.github.io/typblog.github.io/2022/05/23/2022523-new%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/">https://tian-1-2.github.io/typblog.github.io/2022/05/23/2022523-new%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</a></p><h4 id="4、call或apply调用"><a href="#4、call或apply调用" class="headerlink" title="4、call或apply调用"></a><strong>4、call或apply调用</strong></h4><p>跟普通的函数调用相比，用call和apply可以动态的改变函数的this</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">num = <span class="hljs-string">&#x27;&#x27;</span></span>) &#123;<br>        <span class="hljs-keyword">return</span> this.name + num;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-comment">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.getName()); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.getName.call(obj2, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 2 + 2 = 4</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.getName.apply(obj2, [<span class="hljs-number">2</span>])); <span class="hljs-comment">// 2 + 2 = 4</span><br></code></pre></td></tr></table></figure><h4 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5**.箭头函数**"></a>5**.箭头函数**</h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。</p><p>因此，在下面的代码中，传递给<code>getVal</code>函数内的this并不是调用者自身，而是外部的this</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-keyword">val</span>: <span class="hljs-number">1</span>,<br>    getVal: () =&gt; &#123;<br>        console.log(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br>obj.getVal(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>以上五种是this指向的基本情况</p><p>下面在详细介绍一下call和apply</p><h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><h4 id="1-call和apply区别"><a href="#1-call和apply区别" class="headerlink" title="1.call和apply区别"></a>1.call和apply区别</h4><p>先来看区别，是因为它们几乎没有区别，下文代码实例call和apply都可以轻易的切换。</p><p>当它们被设计出来时要做到的事情一摸一样，唯一的区别就在于传参的格式不一样</p><p>apply接受两个参数<br>    第一个参数指定了函数体内this对象的指向<br>    第二个参数为一个带下标的参数集合（可以是数组或者类数组）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span>.apply(obj,args)<span class="hljs-regexp">//</span>obj要改变指向的对象，args为数组或者类数组<br></code></pre></td></tr></table></figure><p>call接受的参数不固定<br>    第一个参数指定了函数体内this对象的指向<br>    第二个参数及以后为函数调用的参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span>.call(obj,args1,args2...)<span class="hljs-regexp">//</span>obj要改变指向的对象，args1,args2...多个参数依次传入<br></code></pre></td></tr></table></figure><p>因为在所有（非箭头）函数中都可以通过arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，它本身就是一个类数组，我们apply在实际使用中更常见一些。</p><p>call是包装在apply上面的语法糖，如果我们明确的知道参数数量，并且希望展示它们，可以使用call。</p><p>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会默认指向宿主对象，在浏览器中则是window。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind的作用是只修改this指向，但不会立即执行fn；</p><p>会返回一个修改了this指向后的fn。</p><p>需要调用才会执行:<code>bind(thisArg, arg1, arg2, arg3, ...)()</code>。</p><p>bind的传参和call相同。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">let obj = &#123;<br>    name: <span class="hljs-string">&quot;xiaoming&quot;</span>,<br>    age: <span class="hljs-number">24</span>,<br>    sayHello: <span class="hljs-keyword">function</span> (job, hobby) &#123;<br>        console.log(`我叫<span class="hljs-variable">$&#123;this.name&#125;</span>,今年<span class="hljs-variable">$&#123;this.age&#125;</span>岁。我的工作是: <span class="hljs-variable">$&#123;job&#125;</span>，我的爱好是: <span class="hljs-variable">$&#123;hobby&#125;</span>。`);<br>    &#125;<br>&#125;<br><span class="hljs-regexp">//</span> obj.sayHello(<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;看美女&#x27;</span>); <span class="hljs-regexp">//</span> 我叫xiaoming,今年<span class="hljs-number">24</span>岁。我的工作是: 程序员，我的爱好是: 看美女。<br><br>let obj1 = &#123;<br>    name: <span class="hljs-string">&quot;lihua&quot;</span>,<br>    age: <span class="hljs-number">30</span><br>&#125;<br>obj.sayHello.bind(obj1, <span class="hljs-string">&#x27;设计师&#x27;</span>, <span class="hljs-string">&#x27;画画&#x27;</span>); <span class="hljs-regexp">//</span> 无输出结果<br>obj.sayHello.bind(obj1, <span class="hljs-string">&#x27;设计师&#x27;</span>, <span class="hljs-string">&#x27;画画&#x27;</span>)(); <span class="hljs-regexp">//</span> 我叫lihua,今年<span class="hljs-number">30</span>岁。我的工作是: 设计师，我的爱好是: 画画。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>And design vue组件库使用注意点</title>
    <link href="/Tian-1-2/typblog/2022/09/25/2022925-And-design-vue%E7%BB%84%E4%BB%B6%E5%BA%93%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/Tian-1-2/typblog/2022/09/25/2022925-And-design-vue%E7%BB%84%E4%BB%B6%E5%BA%93%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="And-design-vue组件库table列设置最小宽度"><a href="#And-design-vue组件库table列设置最小宽度" class="headerlink" title="And design vue组件库table列设置最小宽度"></a>And design vue组件库table列设置最小宽度</h2><p>直接在配置列中加入</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">customCell: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        style: &#123;<br>            <span class="hljs-string">&#x27;min-width&#x27;</span>: <span class="hljs-string">&#x27;100px&#x27;</span>,<br>        &#125;,<br>    &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><p>如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3704e5b3f2bfef5c922ee21f5b4cbcf3.jpeg" alt="img"></p><h2 id="And-design-vue-自定义上传图片"><a href="#And-design-vue-自定义上传图片" class="headerlink" title="And design vue 自定义上传图片"></a>And design vue 自定义上传图片</h2><p>直接去除action 定义customRequest</p><p><img src="https://img-blog.csdnimg.cn/img_convert/538a8a52c89d76021e24654454e3589f.jpeg" alt="img"></p><p>注意方法需要先new一个FormData</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ee135c4dd68a180a3eba3ff6a0763f2.jpeg" alt="img"></p><h2 id="And-design-vue-挑选表格前面设定的值"><a href="#And-design-vue-挑选表格前面设定的值" class="headerlink" title="And design vue 挑选表格前面设定的值"></a>And design vue 挑选表格前面设定的值</h2><p>直接在表格上定义row-key</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ec5b4abc1181f670a15de0b042082998.jpeg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>And design vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的括号--算法练习</title>
    <link href="/Tian-1-2/typblog/2022/09/23/2022923-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7--%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/Tian-1-2/typblog/2022/09/23/2022923-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7--%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="leetcode20-有效的括号"><a href="#leetcode20-有效的括号" class="headerlink" title="leetcode20.有效的括号"></a>leetcode20.有效的括号</h3><p>题目：</p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>思路： 这道题有一规律：</p><ol><li>右括号前面，必须是相对应的左括号，才能抵消！</li><li>右括号前面，不是对应的左括号，那么该字符串，一定不是有效的括号！</li></ol><p>也就是说左括号我们直接放入栈中即可，发现是右括号就要对比是否跟栈顶元素相匹配，不匹配就返回false</p><p>所以先设定好map，再判定是否是左边的括号，是则进栈，不是则判定与最后一个进栈的括号是否匹配，如果匹配那么则出栈，不匹配则返回false，</p><p>最后再判断已经全部出栈，如果没有全部出栈，则也说明括号没有完全匹配</p><p>具体代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">var isValid = <span class="hljs-built_in">function</span>(s) &#123;<br>    <span class="hljs-type">const</span> map = &#123; <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-string">&#x27;]&#x27;</span> &#125;;<br>    <span class="hljs-type">const</span> stack = [];<br>    <span class="hljs-keyword">for</span>(let i of s)&#123;<br>        <span class="hljs-keyword">if</span>(map[i])&#123;<br>            stack.<span class="hljs-built_in">push</span>(i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(map[stack[stack.length - <span class="hljs-number">1</span>]] === i)&#123;<br>                stack.<span class="hljs-built_in">pop</span>()<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中的key有什么作用</title>
    <link href="/Tian-1-2/typblog/2022/09/22/2022922-vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/"/>
    <url>/Tian-1-2/typblog/2022/09/22/2022922-vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vue中的key有什么作用"><a href="#vue中的key有什么作用" class="headerlink" title="vue中的key有什么作用"></a>vue中的key有什么作用</h2><p>key是虚拟dom中的对象标识，</p><p>当数据发生变化时，vue会根据新数据生成新的虚拟dom，随后vue进行新dom与旧虚拟dom对比</p><p>而这个对比规则如下</p><p>1.第一种情况：”当旧虚拟Dom找到了与新虚拟DOM相同的key</p><p>如果虚拟dom中内容没有变，就直接使用之前的真实dom，如果虚拟dom中的内容变了，则生成新的真实dom，随后替换页面中之前的真实dom</p><p>2.第二种情况：当虚拟dom没有找到与新虚拟dom相同的key，就会直接创建新的真实dom，随后渲染到页面</p><p>key值的选择一般用每条数据的唯一标识作为key，</p><p>若用index作为key会引发一些问题，比如添加删除，会破坏顺序的操作，产生没有必要的dom更新</p><h5 id="那开发中如何选择key"><a href="#那开发中如何选择key" class="headerlink" title="那开发中如何选择key?"></a>那开发中如何选择key?</h5><p>最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值</p><p>如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key是没有问题的</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行内元素 块级元素</title>
    <link href="/Tian-1-2/typblog/2022/09/22/2022922-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/"/>
    <url>/Tian-1-2/typblog/2022/09/22/2022922-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3></li><li><ul><li><p>行内元素（内联元素）：不占有独立的区域，仅仅依靠自己的字体大小或者是图像大小来支撑结构。 一般不可以设置宽度，高度以及对齐等属性。</p></li><li><p><strong>特点：</strong></p></li><li><ul><li>和相邻的行内元素在一行上</li><li>高度和宽度无效，但是水平方向上的padding和margin可以设置，垂直方向上的无效</li><li>默认的宽度就是它本身的宽度</li><li>行内元素只能容纳纯文本或者是其他的行内元素（a标签除外）</li></ul></li><li><p>常见的有： a b span select strong em del</p></li></ul></li><li><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3></li><li><ul><li><p>每个块级元素通常都会独占一行或者是多行，可以对其单独设置高度,宽度以及对齐等属性。</p></li><li><p><strong>特点：</strong></p></li><li><ul><li>块级元素会独占一行</li><li>高度，行高，外边距和内边距都可以单独设置</li><li>宽度默认是容器的100%</li><li>可以容纳内联元素和其他的块级元素</li></ul></li><li><p>常见的有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</p></li></ul></li><li><h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3></li><li><ul><li><p>块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元宽度和高度，</p></li><li><p>也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。</p></li><li><p><strong>特点</strong></p></li><li><ul><li>和相邻的行内元素（行内块）在一行上，但是中间会有空白的间隙</li><li>默认的宽度就是本身内容的宽度</li><li>高度，行高，内边距和外边距都可以设置</li></ul></li><li><p>常见的有： img input td</p></li></ul></li><li><h3 id="如何将行内元素转为块级元素"><a href="#如何将行内元素转为块级元素" class="headerlink" title="如何将行内元素转为块级元素"></a>如何将行内元素转为块级元素</h3></li><li><ul><li>display：block ，定义元素为块级元素</li><li>display : inline ，定义元素为行内元素</li><li>display：inline-block，定义元素为行内块</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅拷贝、深拷贝，手撕深拷贝</title>
    <link href="/Tian-1-2/typblog/2022/09/19/2022919-%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%89%8B%E6%92%95%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/Tian-1-2/typblog/2022/09/19/2022919-%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%89%8B%E6%92%95%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝、深拷贝，手撕深拷贝"><a href="#浅拷贝、深拷贝，手撕深拷贝" class="headerlink" title="浅拷贝、深拷贝，手撕深拷贝"></a>浅拷贝、深拷贝，手撕深拷贝</h2><p>这里牵扯到JS中的数据类型了，可以分为基本类型与引用类型</p><p>基本类型数据保存在在栈内存中</p><p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p>指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><ul><li>Object.assign</li><li>Array.prototype.slice(), </li><li>使用拓展运算符实现的复制</li></ul><p><strong>深拷贝</strong></p><p>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><ul><li>_.cloneDeep()</li><li>jQuery.extend()</li><li>JSON.stringify() 缺点：会忽略undefined、symbol和函数</li><li>手写循环递归</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>)&#123;<br><span class="hljs-keyword">if</span>(obj==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;<span class="hljs-comment">//如果是null或者undefined就不进行拷贝操作</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj);<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj);<br>      <span class="hljs-comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> ob<br><span class="hljs-comment">//这里判断是数组还是对象便于生成objclone的类型</span><br><span class="hljs-keyword">var</span> objclone=<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)?[]:&#123;&#125;<br><span class="hljs-keyword">if</span> (obj&amp;&amp;<span class="hljs-keyword">typeof</span> obj=<span class="hljs-string">&quot;Object&quot;</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;<br><span class="hljs-comment">//如果obj[key]为对象，就再次进入循环</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key]=<span class="hljs-string">&quot;Object&quot;</span>)&#123;<br>objclone[key]=<span class="hljs-title function_">copy</span>(obj[key])<br>&#125;eles&#123;<br><span class="hljs-title function_">objclone</span>(key)=obj[key]<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> objclone<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型与原型链</title>
    <link href="/Tian-1-2/typblog/2022/09/13/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/Tian-1-2/typblog/2022/09/13/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><strong>概述</strong></p><p>每个函数都有一个prototype属性，指向一个对象，而这个对象就是原型对象</p><p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p><p>每一个对象有自己的原型对象，而原型对象又有自己的原型对象，因此会形成一个原型链，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，也在该对象的原型上搜寻，以及该对象的原型的原型，依次层层向上搜寻，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>下面的图即详细解释了原型链详细的构成</p><p><img src="https://gitee.com/typhome/typora-image-library/raw/master/img/202210171435766.png" alt="image-20221017143519721"></p><p>我在csdn上看到了一个大佬讲的非常详细，这里推荐一下：<a href="https://yuguang.blog.csdn.net/article/details/106555301?spm=1001.2014.3001.5506">https://yuguang.blog.csdn.net/article/details/106555301?spm=1001.2014.3001.5506</a></p><p><strong>道理都懂了，该如何去叙述呢，往下看</strong></p><p>接下来就是我对原型链的总结</p><p>首先我们先看构造函数与原型对象的原型，构造函数中的prototype属性即显式原型指向其原型对象，</p><p>而原型对象中都有一个constructor属性，该constructor属性就会执行该对象的构造函数，</p><p>接下来我们加入由构造函数创建的实例对象，而实例对象中都有一个__proto__属性，我们也称为隐式原型，该隐式原型可以直接让实例对象指向该构造函数的原型对象</p><p>而原型对象是通过object构造函数生成的（这里和new有关），new创建实例时，new过程中会创建一个新的object对象，而该对象的隐形原型会指向构造函数的的原型对象，</p><p>所以该构造函数的原型对象有一个属性__proto__隐形原型指向object的原型对象，而object原型对象和object构造函数又有prototype和constructor相互指向的关系，因此形成了最终的原型链，而这个链条还存在最终点，是因为：Object.prototype 的原型是——null，null 表示“没有对象”，即该处不应该有值。这句话也意味着 Object.prototype 没有原型</p><p>这就是一个原型链形成的完整过程。</p><p>在后续的学习中许多地方都会涉及到原型链，比如vue实例、组件实例和他们原型对象之间的关系。后续的文章我也会做详细的讲解</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP常见的状态码</title>
    <link href="/Tian-1-2/typblog/2022/09/13/2022913-HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/Tian-1-2/typblog/2022/09/13/2022913-HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>HTTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码</p><p>它由 RFC 2616规范定义的，并得到 <code>RFC 2518</code>、<code>RFC 2817</code>、<code>RFC 2295</code>、<code>RFC 2774</code>与 <code>RFC 4918</code>等规范扩展</p><p>简单来讲，<code>http</code>状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p>状态码第一位数字决定了不同的响应状态，这里先概述一下，有如下：</p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示客户端请求错误</li><li>5 表示服务器错误</li></ul><h3 id="接下来对每个状态码做详细的介绍"><a href="#接下来对每个状态码做详细的介绍" class="headerlink" title="接下来对每个状态码做详细的介绍"></a>接下来对每个状态码做详细的介绍</h3><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p><p>常见的有：</p><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li></ul><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>代表请求已成功被服务器接收、理解、并接受</p><p>常见的有：</p><ul><li><strong>200</strong>（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202（已创建）：服务器已经接收请求，但尚未处理</li><li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li><li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li><li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li><li>206（部分内容）：服务器成功处理了部分请求</li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p><p>常见的有：</p><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li><li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li><li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p><p>常见的有：</p><ul><li><strong>400</strong>（错误请求）： 服务器不理解请求的语法，该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li><li><strong>401</strong>（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应，该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</li><li><strong>403</strong>（禁止）： 服务器拒绝请求</li><li><strong>404</strong>（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p><p>常见的有：</p><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js中的数据类型</title>
    <link href="/Tian-1-2/typblog/2022/09/12/2022912-Js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/Tian-1-2/typblog/2022/09/12/2022912-Js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在<code>JavaScript</code>中，我们可以分成两种类型：</p><ul><li>基本类型</li><li>复杂类型</li></ul><p>两种类型的区别是：存储位置不同</p><h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><p>基本类型主要为以下6种：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>null</li><li>symbol</li></ul><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> intNum = <span class="hljs-number">55</span> <span class="hljs-comment">// 10进制的55</span><br><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">070</span> <span class="hljs-comment">// 8进制的56</span><br><span class="hljs-keyword">let</span> hexNum1 = <span class="hljs-number">0xA</span> <span class="hljs-comment">//16进制的10</span><br></code></pre></td></tr></table></figure><p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> floatNum1 = <span class="hljs-number">1.1</span>;<br><span class="hljs-keyword">let</span> floatNum2 = <span class="hljs-number">0.1</span>;<br><span class="hljs-keyword">let</span> floatNum3 = <span class="hljs-number">.1</span>; <span class="hljs-comment">// 有效，但不推荐</span><br><span class="hljs-keyword">let</span> floatNum = <span class="hljs-number">3.125e7</span>; <span class="hljs-comment">// 等于 31250000</span><br></code></pre></td></tr></table></figure><p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">0</span>/+<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>。当使用 <code>var</code>或 <code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code>值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>包含<code>undefined</code> 值的变量跟未定义变量是有区别的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message; <span class="hljs-comment">// 这个变量被声明了，只是值为 undefined</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 没有声明过这个变量，报错</span><br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-string">&#x27;Jacob&#x27;</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-string">`Jingleheimerschmidt`</span><br></code></pre></td></tr></table></figure><p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lang = <span class="hljs-string">&quot;Java&quot;</span>;<br>lang = lang + <span class="hljs-string">&quot;Script&quot;</span>;  <span class="hljs-comment">// 先销毁再创建</span><br></code></pre></td></tr></table></figure><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">Null</span><span class="hljs-string">`类型同样只有一个值，即特殊值 `</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>逻辑上讲， null 值表示一个空对象指针，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> car = <span class="hljs-literal">null</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> car); <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p><code>undefined</code> 值是由 <code>null</code>值派生而来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 <code>null</code>来填充该变量</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Boolean</span><span class="hljs-string">`（布尔值）类型有两个字面值： `</span><span class="hljs-literal">true</span><span class="hljs-string">` 和`</span><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值</p><p>规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">数据类型      转换为 <span class="hljs-literal">true</span> 的值      转换为 <span class="hljs-literal">false</span> 的值<br> <span class="hljs-title class_">String</span>         非空字符串          <span class="hljs-string">&quot;&quot;</span> <br> <span class="hljs-title class_">Number</span> 非零数值（包括无穷值）<span class="hljs-number">0</span> 、 <span class="hljs-title class_">NaN</span> <br> <span class="hljs-title class_">Object</span>  任意对象    <span class="hljs-literal">null</span><br><span class="hljs-title class_">Undefined</span> N/A （不存在） <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> genericSymbol = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> otherGenericSymbol = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> otherFooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol == otherFooSymbol); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="二、引用类型"><a href="#二、引用类型" class="headerlink" title="二、引用类型"></a>二、引用类型</h2><p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p><ul><li>Object</li><li>Array</li><li>Function</li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>创建<code>object</code>常用方式为对象字面量表示法，属性名可以是字符串或数值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-number">5</span>: <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><code>JavaScript</code>数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-number">2</span>, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;]<br>colors.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>函数实际上是对象，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样</p><p>函数存在三种常见的表达方式：</p><ul><li>函数声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (num1, num2) &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>箭头函数</li></ul><p>函数声明和函数表达式两种方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1, num2</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h3><p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等……</p><h2 id="三、存储区别"><a href="#三、存储区别" class="headerlink" title="三、存储区别"></a>三、存储区别</h2><p>基本数据类型和引用数据类型存储在内存中的位置不同：</p><ul><li>基本数据类型存储在栈中</li><li>引用类型的对象存储于堆中</li></ul><p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p><p>下面来举个例子</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// 赋值操作</span><br>b = <span class="hljs-number">20</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 10值</span><br></code></pre></td></tr></table></figure><p><code>a</code>的值为一个基本类型，是存储在栈中，将<code>a</code>的值赋给<code>b</code>，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p><p>下图演示了基本类型赋值的过程：</p><p><img src="https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = obj1;<br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Xxx&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// xxx</span><br></code></pre></td></tr></table></figure><p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</p><p><code>obj1</code>是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了<code>obj2</code>，实际上他们共同指向了同一个堆内存对象，所以更改<code>obj2</code>会对<code>obj1</code>产生影响</p><p>下图演示这个引用类型赋值过程</p><p><img src="https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png" alt="img"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>声明变量时不同的内存地址分配：<ul><li>简单类型的值存放在栈中，在栈中存放的是对应的值</li><li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li></ul></li><li>不同的类型数据导致赋值变量时的不同：<ul><li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li><li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git日程开发常用命令</title>
    <link href="/Tian-1-2/typblog/2022/08/13/2022813-git%E6%97%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/Tian-1-2/typblog/2022/08/13/2022813-git%E6%97%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git日常开发常用命令"><a href="#git日常开发常用命令" class="headerlink" title="git日常开发常用命令"></a>git日常开发常用命令</h2><p>连接远程仓库：git remote add origin ssh地址</p><p>创建分支并切换到该分支： git checkout -b 分支名称 相当于 git branch dev git checkout dev</p><p>切换分支： git checkout develop</p><p>添加到暂存区：git add .</p><p>把暂存区内容提交到当前分支：git commit “….”</p><p>最新的提交从origin&#x2F;dev抓下来：git pull origin 分支名</p><p>上传到分支仓库：git push origin 分支名</p><p>克隆到本地仓库：git clone 地址</p><p>其实最常用的流程是下面的</p><p>git add .</p><p>git commit “….”</p><p>git pull origin 分支名 最新的提交从origin&#x2F;dev抓下来，然后，在本地合并，解决冲突 再推送</p><p>git push origin dev 上传到分支仓库</p><p>这是一个完整的提交过程，git pull这一步不要忘记了，更新远程仓库的最新代码，可能会出现冲突，一定要解决完冲突再提交。</p><p>这里推荐一个廖雪峰大佬的git教程，里面的知识点讲的很详细</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new手写实现过程</title>
    <link href="/Tian-1-2/typblog/2022/05/23/2022523-new%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
    <url>/Tian-1-2/typblog/2022/05/23/2022523-new%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="new命令的基本用法"><a href="#new命令的基本用法" class="headerlink" title="new命令的基本用法"></a>new命令的基本用法</h2><p><code>new</code>命令的作用，就是执行构造函数，返回一个实例对象。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br>v.price <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><h2 id="new命令的原理"><a href="#new命令的原理" class="headerlink" title="new命令的原理"></a>new命令的原理</h2><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>开始执行构造函数内部的代码。</li></ol><h2 id="手写new命令过程"><a href="#手写new命令过程" class="headerlink" title="手写new命令过程"></a>手写new命令过程</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span><span class="hljs-params">(Func, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-comment">// 1.创建一个新对象</span><br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    <span class="hljs-comment">// 2.新对象原型指向构造函数原型对象</span><br>    obj.__proto__ = Func.prototype<br>    <span class="hljs-comment">// 3.将构建函数的this指向新对象</span><br>    let result = Func.apply(obj, args)<br>    <span class="hljs-comment">// 4.根据返回值判断，如果对象没有返回值，result会为undefine</span><br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> Object ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span><span class="hljs-params">(func, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    obj.__proto__ = func.prototype<br>    let result = func.apply(obj, args)<br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> Object ? result : obj<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span> &#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br>Person.prototype.say = <span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123;<br>    console.log(<span class="hljs-keyword">this</span>.name)<br>&#125;<br><br>let p = mynew(Person, <span class="hljs-string">&quot;huihui&quot;</span>, <span class="hljs-number">123</span>)<br>console.log(p) <span class="hljs-comment">// Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span><br>p.say() <span class="hljs-comment">// huihui</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖与节流</title>
    <link href="/Tian-1-2/typblog/2022/05/23/2022523-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/Tian-1-2/typblog/2022/05/23/2022523-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p><strong>防抖</strong>：当持续触发事件时，会等到停止后一段时间才开始执行</p><p>应用场景：表单验证，按键提交</p><p>实现原理：利用setTimeout ，每次调用都会用clearTimeout清除前一次的定时器</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>            <span class="hljs-keyword">var</span> timeout;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">//记录当前this</span><br>                <span class="hljs-keyword">var</span> arg=<span class="hljs-variable language_">arguments</span>; <span class="hljs-comment">//记录当前参数</span><br>                <span class="hljs-built_in">clearTimeout</span>(timeout)<br>                timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                    <span class="hljs-comment">//经过匿名函数指向，this指向已经指向windows,所以早着需要修改this指向</span><br>                    func.<span class="hljs-title function_">apply</span>(context,arg)<br>                &#125;, wait);<br>            &#125;<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">onwheel</span>=<span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">11</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p><strong>节流：</strong>会每隔一段时间，才执行执行一次</p><p>应用场景：Dom拖拽，需要计算鼠标移动距离</p><p>实现原理：设定固定事件间隔，判断有没有超过时间</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>            <span class="hljs-keyword">var</span> context, args;<br>            <span class="hljs-keyword">var</span> previous = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">var</span> <span class="hljs-built_in">now</span> = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>            context = this;<br>            args = arguments;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">now</span> - previous &gt; wait) &#123;<br>                func.apply(context, args);<br>                previous = <span class="hljs-built_in">now</span>;<br>            &#125;<br>            <span class="hljs-comment">// 时间没到，啥都不干</span><br>        &#125;<br>&#125;<br>document.onwheel=throttle(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">11</span>);<br>&#125;,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序（Bubble Sort）</title>
    <link href="/Tian-1-2/typblog/2022/05/08/202258-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89/"/>
    <url>/Tian-1-2/typblog/2022/05/08/202258-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><p>时间复杂度：O（n^2）</p><p>空间复杂度：O（1)</p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong></p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img"></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-built_in">length</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;        <span class="hljs-comment">// 相邻元素两两对比</span><br>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 元素交换</span><br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [6, 5, 4, 3, 2, 1]</span><br>bubbleSort(arr);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加一--算法练习</title>
    <link href="/Tian-1-2/typblog/2022/04/25/20221025-%E5%8A%A0%E4%B8%80--%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/Tian-1-2/typblog/2022/04/25/20221025-%E5%8A%A0%E4%B8%80--%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode66-加一"><a href="#leetcode66-加一" class="headerlink" title="leetcode66.加一"></a>leetcode66.加一</h2><p>题目：</p><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,2,4]</span><br>解释：输入数组表示数字 123。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：digits = [<span class="hljs-number">4,3,2,1</span>]<br>输出：[<span class="hljs-number">4,3,2,2</span>]<br>解释：输入数组表示数字 <span class="hljs-number">4321</span>。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>这道题会有多种情况，可以先分析一下各种情况</p><ol><li><p>末位无进位，则末位加一即可，因为末位无进位，前面也不可能产生进位，比如 45 &#x3D;&gt; 46</p></li><li><p>末位有进位，在中间位置进位停止，则需要找到进位的典型标志，即为当前位 %10后为 0，则前一位加 1，直到不为 0 为止，比如 499 &#x3D;&gt; 500</p></li><li><p>末位有进位，并且一直进位到最前方导致结果多出一位，对于这种情况，需要在第 2 种情况遍历结束的基础上，进行单独处理，比如 999 &#x3D;&gt; 1000</p></li></ol><p>分析过后就很明了了，直接上代码</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ada">var plusOne = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">digits</span>) &#123;<br>    const len = <span class="hljs-keyword">digits</span>.length;<br>    //<span class="hljs-keyword">for</span>循环内这里是第一种情况和第二种情况<br>    <span class="hljs-keyword">for</span>(let i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>        <span class="hljs-keyword">digits</span>[i]++;<br>        <span class="hljs-keyword">digits</span>[i] %= <span class="hljs-number">10</span>;<br>        //这里判断如何某一位不为零，说明不是第三种，那直接<span class="hljs-keyword">return</span>结束循环<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">digits</span>[i]!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">digits</span>;<br>    &#125;<br>    //这里如果前面没有<span class="hljs-keyword">return</span>那么说明这里是第三种方法，已经进位到最高位了，这时候我们多加一位，全部归化为零，在下方第一位再设为<span class="hljs-number">1</span><br>    <span class="hljs-keyword">digits</span> = [...<span class="hljs-keyword">Array</span>(len + <span class="hljs-number">1</span>)].map(_=&gt;<span class="hljs-number">0</span>);;<br>    <span class="hljs-keyword">digits</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">digits</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>清除浮动的几种方法</title>
    <link href="/Tian-1-2/typblog/2022/04/15/2022413-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/Tian-1-2/typblog/2022/04/15/2022413-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>在清除浮动之前我们需要了解为什么要清除浮动</strong></p><p>浮动的定义：非ie浏览器下，容器不设高度且子元素浮动时，容器布局不能被内容撑开，此时内容会溢出到容器外面而影响布局，这种现象被称为浮动</p><p>而清除浮动主要是为了解决，父元素因为子级元素浮动引起的内部高度为0的问题，即高度塌陷</p><p>下面就是在子元素都添加了浮动后，引起父元素的高度塌陷：</p><p><img src="https://img-blog.csdnimg.cn/285cc0eb94254b6a85e5a4412bb01668.png" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chrild1&quot;</span>&gt;</span>chrild1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chrild2&quot;</span>&gt;</span>chrild2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chrild3&quot;</span>&gt;</span>chrild3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.father</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">240</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>);</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.chrild1</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.chrild2</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: chartreuse;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.chrild3</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">231</span>, <span class="hljs-number">17</span>, <span class="hljs-number">156</span>);</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 接下来进入正题介绍清除浮动的方法</p><h5 id="1-给父级元素定义height属性"><a href="#1-给父级元素定义height属性" class="headerlink" title="1.给父级元素定义height属性"></a>1.给父级元素定义height属性</h5><p>缺点： 需要手动添加高度，如何后面的高度发生变化，还要再次修改高度，给后期的维护带来麻烦。</p><p><img src="https://img-blog.csdnimg.cn/3ba3b84db9294e40a0bc60ecc3705c8d.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span>&#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">240</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>);<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="2-最后一个浮动元素之后添加一个空的div标签，并添加clear：both样式"><a href="#2-最后一个浮动元素之后添加一个空的div标签，并添加clear：both样式" class="headerlink" title="2.最后一个浮动元素之后添加一个空的div标签，并添加clear：both样式"></a>2.最后一个浮动元素之后添加一个空的div标签，并添加clear：both样式</h5><p>clear：both的作用是不允许周围有浮动现象</p><p>缺点：结构化比较差，对于比较复杂的页面就显得结构非常的乱。</p><p><img src="https://img-blog.csdnimg.cn/a758f281eedd48eea75d77f0247d6158.png" alt="img"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">.chrild4&#123;<br>            clear: both;<br>        &#125;<br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">father</span>&quot;&gt;<br><br>        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild1</span>&quot;&gt;<span class="hljs-symbol">chrild1</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild2</span>&quot;&gt;<span class="hljs-symbol">chrild2</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild3</span>&quot;&gt;<span class="hljs-symbol">chrild3</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild4</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br><br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="3-触发BFC，在父元素中添加overflow"><a href="#3-触发BFC，在父元素中添加overflow" class="headerlink" title="3.触发BFC，在父元素中添加overflow"></a>3.触发BFC，在父元素中添加overflow</h5><p>缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素。</p><p><img src="https://img-blog.csdnimg.cn/a758f281eedd48eea75d77f0247d6158.png" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span>&#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">240</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>);<br>            <span class="hljs-attribute">overflow</span>: hidden;<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="4-使用after伪元素清除浮动（较推荐）"><a href="#4-使用after伪元素清除浮动（较推荐）" class="headerlink" title="4.使用after伪元素清除浮动（较推荐）"></a>4.使用after伪元素清除浮动（较推荐）</h5><p>利用after伪元素定义一个clearfix类，浮动元素的父级元素调用此类可以实现清除浮动的效果</p><p><img src="https://img-blog.csdnimg.cn/a758f281eedd48eea75d77f0247d6158.png" alt="img"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">.clearfix::after &#123;<br>        content: <span class="hljs-string">&quot;&quot;</span>;<br>       display: table;<br>        height: <span class="hljs-number">0</span>;<br>        clear:both;<br>        visibility: hidden;<br>&#125;<br><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">father</span> <span class="hljs-symbol">clearfix</span>&quot;&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild1</span>&quot;&gt;<span class="hljs-symbol">chrild1</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild2</span>&quot;&gt;<span class="hljs-symbol">chrild2</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild3</span>&quot;&gt;<span class="hljs-symbol">chrild3</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">chrild4</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="5-使用后before和after双伪元素清除浮动（较推荐）"><a href="#5-使用后before和after双伪元素清除浮动（较推荐）" class="headerlink" title="5.使用后before和after双伪元素清除浮动（较推荐）"></a>5.使用后before和after双伪元素清除浮动（较推荐）</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>,<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table;<br><span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组的常用方法</title>
    <link href="/Tian-1-2/typblog/2022/04/13/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/Tian-1-2/typblog/2022/04/13/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="会改变原数组的方法："><a href="#会改变原数组的方法：" class="headerlink" title="会改变原数组的方法：**"></a>会改变原数组的方法：**</h3><ol><li><p>push() 用于在数组的末端添加一个或多个元素</p></li><li><p>pop() 方法用于删除数组的最后一个元素，并且返回该元素</p></li><li><p>shift()   方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p></li><li><p>unshift()方法用于第一个位置添加元素，并返回添加新元素后的数组长度，也会改变原数组。可以接受多个参数</p></li><li><p>reverse() 用于颠倒排列数组元素，返回改变后的数组，会改变原数组</p></li><li><p>splice() 方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p></li><li><ol><li>arr.splice(start, count, addElement1, addElement2, …);</li><li>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</li></ol></li><li><p>sort() 方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p></li></ol><p>sort可以传入一个函数作为参数 </p><p>​    <img src="data:image/png;base64,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" alt="0"></p><p>上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a><strong>其他方法</strong></h3><p>valueOf() 返回数组本身</p><p>toString() 返回数组的字符串形式</p><p>join() 以指定参数作为分隔符，将所有数组成员连接为一个字符串返回，如果不提供参数，默认用逗号分隔</p><p>concat() 用于多个数组的合并，并将新数组的成员，添加到原数组的后面，返回一个新数组    [ ‘hello’].concat([‘world’]&#x2F;&#x2F; [“hello”, “world”]</p><p>slice()方法用于提取目标数组的一部分，返回一个新数组，原数组不变。  arr.slice(start, end);</p><ul><li><ul><li>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</li><li>如果slice()方法的参数是负数，则表示倒数计算的位置。</li></ul></li><li><p>map()方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p></li><li><p>forEach()方法与map()方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach()方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map()方法，否则使用forEach()方法。</p></li><li><p>filter()方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p></li><li><p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</p></li><li><p>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</p></li><li><p>reduce()方法和reduceRight()方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce()是从左到右处理（从第一个成员到最后一个成员），reduceRight()则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p></li><li><ul><li>reduce( function(a,b){}) 只有一个参数时 第一次执行时a表示第一个成员  再次执行时 为上一次执行的返回值 </li><li>reduce第二个参数为默认值 那么第一次执行时a的值就为设定的默认值</li></ul></li><li><p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。indexOf方法还可以接受第二个参数，表示搜索的开始位置。</p></li><li><p>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p></li><li><p>filter用于对数组进行过滤。返回符合条件的元素组成的新数组</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索插入位置--算法练习</title>
    <link href="/Tian-1-2/typblog/2022/02/22/20221022-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE--%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/Tian-1-2/typblog/2022/02/22/20221022-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE--%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="leetcode35-搜索插入位置"><a href="#leetcode35-搜索插入位置" class="headerlink" title="leetcode35.搜索插入位置"></a>leetcode35.搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p>有序？查找？二分法直接上</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> searchInsert = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">right</span>=nums.<span class="hljs-built_in">length</span><span class="hljs-number">-1</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">left</span>&lt;=<span class="hljs-built_in">right</span>)&#123;<br>   <span class="hljs-comment">//这里需要注意一点js中的/会保留小数，所以需要向下取整一下</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-built_in">mid</span>=Math.<span class="hljs-built_in">floor</span>((<span class="hljs-built_in">left</span>+<span class="hljs-built_in">right</span>)/<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-built_in">mid</span>]&lt;target)&#123;<br>            <span class="hljs-built_in">left</span>=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[<span class="hljs-built_in">mid</span>]&gt;target)&#123;<br>            <span class="hljs-built_in">right</span>=<span class="hljs-built_in">mid</span><span class="hljs-number">-1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">mid</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css文本一行或者多行多余部分用省略号代替</title>
    <link href="/Tian-1-2/typblog/2022/02/13/%E5%A4%9A%E4%BD%99%E6%96%87%E6%9C%AC%E7%9C%81%E7%95%A5/"/>
    <url>/Tian-1-2/typblog/2022/02/13/%E5%A4%9A%E4%BD%99%E6%96%87%E6%9C%AC%E7%9C%81%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>对于一行文本多余部分用省略号代替，常用下面的方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">white-space</span>:nowrap;<br></code></pre></td></tr></table></figure><p> 对于两行或者多行常用下面的方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">display</span>: -webkit-box;<br>-webkit-line-clamp: <span class="hljs-number">2</span>;<br>-webkit-box-orient: vertical;<br></code></pre></td></tr></table></figure><p>这里设置的是两行文本，更改-webkit-line-clamp的值可以设置多行文本的多余部分省略。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
